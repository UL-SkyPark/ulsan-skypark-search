<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>울산하늘공원 데이터 관리자</title>

  <link rel="icon" type="image/x-icon" href="./images/symbol.png">
  <link rel="apple-touch-icon" href="./images/symbol.png">

  <!-- Handsontable -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/handsontable/dist/handsontable.full.min.css" />
  <script src="https://cdn.jsdelivr.net/npm/handsontable/dist/handsontable.full.min.js"></script>

  <!-- XLSX -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <style>
    :root{
      /* Pastel Warm (Down-toned) */
      --bg:#fbfaf7;
      --panel:#ffffff;
      --text:#0f172a;
      --muted:#6b7280;
      --line:#ece7dd;

      --primary:#f3d6a1;
      --primary-h:#eac88b;
      --accent:#fff2d6;

      --success:#63cdb0;
      --success-h:#55bfA3;

      --ghost:#fdf3e6;
      --ghost-h:#f7ead7;

      --danger:#b42318;

      --shadow: 0 14px 38px rgba(15, 23, 42, 0.08);
      --radius:16px;
    }

    *{ box-sizing:border-box; }
    body{
      margin:0;
      padding:22px;
      background:
        radial-gradient(1200px 600px at 50% -240px, rgba(243,214,161,0.14), rgba(0,0,0,0)),
        radial-gradient(900px 520px at 12% 12%, rgba(255,242,214,0.20), rgba(0,0,0,0)),
        var(--bg);
      color:var(--text);
      font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Apple SD Gothic Neo", "Noto Sans KR", sans-serif;
      display:flex;
      justify-content:center;
      font-size:16px;
    }

    .container{
      width:100%;
      max-width:1280px;
      background:var(--panel);
      border:1px solid var(--line);
      border-radius:20px;
      box-shadow:var(--shadow);
      overflow:hidden;
    }

    .header{
      padding:18px 20px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      border-bottom:1px solid var(--line);
      background: linear-gradient(180deg, rgba(243,214,161,0.12), rgba(255,255,255,1));
    }
    .header-left{
      display:flex;
      flex-direction:column;
      gap:10px;
      min-width:0;
    }
    .title{
      font-size:28px;
      font-weight:950;
      letter-spacing:-0.4px;
      margin:0;
      line-height:1.1;
    }

    .badges{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      min-height:34px;
    }
    .badge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:9px 13px;
      border-radius:999px;
      font-size:14px;
      font-weight:850;
      color:#3b2f13;
      background:#f7f2e8;
      border:1px solid #e8e1d2;
      white-space:nowrap;
    }
    .badge b{ font-weight:950; }
    .badge.hidden{ display:none !important; }

    .header-right{
      display:flex;
      align-items:center;
      gap:12px;
      flex-shrink:0;
    }
    .logo{
      height:44px;
      width:auto;
      display:block;
    }

    .content{ padding:16px 18px 18px; }

    .box{
      background:#fff;
      border:1px solid var(--line);
      border-radius:var(--radius);
      padding:16px;
      margin-bottom:14px;
    }
    .box-title{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      font-weight:950;
      margin-bottom:12px;
      color:#0f172a;
      font-size:17px;
    }
    .hint-mini{
      font-size:14px;
      font-weight:850;
      color:var(--muted);
    }

    .row{
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(260px,1fr));
      gap:12px;
      margin:0;
    }
    .form-group label{
      display:block;
      font-weight:900;
      font-size:14px;
      margin-bottom:8px;
      color:#334155;
    }
    .form-group input{
      width:100%;
      padding:13px 12px;
      border:1px solid var(--line);
      border-radius:14px;
      background:#fff;
      font-size:16px;
      outline:none;
      transition:0.15s;
    }
    .form-group input:focus{
      border-color:#e8d9bf;
      box-shadow:0 0 0 5px rgba(243,214,161,0.16);
    }

    .toolbar{
      margin-top:12px;
      display:flex;
      align-items:center;
      justify-content:flex-end;
      gap:10px;
      flex-wrap:wrap;
      position:relative;
    }

    .btn{
      border:1px solid transparent;
      padding:12px 16px;
      border-radius:14px;
      font-size:16px;
      font-weight:950;
      cursor:pointer;
      transition:0.15s;
      display:inline-flex;
      align-items:center;
      gap:8px;
    }
    .btn:disabled{ opacity:0.55; cursor:not-allowed; }
    .btn:hover{ transform: translateY(-1px); }
    .btn:active{ transform: translateY(0px); }
    .btn:focus-visible{
      outline:none;
      box-shadow:0 0 0 5px rgba(243,214,161,0.18);
    }

    .btn-primary{
      background: linear-gradient(180deg, rgba(255,247,231,0.98), rgba(243,214,161,0.88));
      color:#2b1f09;
      border-color: rgba(234,200,139,0.40);
      box-shadow: 0 10px 16px rgba(243,214,161,0.14);
    }

    .btn-ghost{
      background:var(--ghost);
      border-color:#e8e1d2;
      color:#2b1f09;
    }

    .input-with-btn{
      display:flex;
      gap:10px;
      align-items:center;
    }
    .icon-btn{
      border:1px solid #e8e1d2;
      background:#f7f2e8;
      color:#2b1f09;
      padding:12px 14px;
      border-radius:14px;
      font-weight:950;
      cursor:pointer;
      transition:0.15s;
      white-space:nowrap;
    }
    .icon-btn:hover{ background:#f1ebdf; transform: translateY(-1px); }
    .field-help{
      margin-top:8px;
      font-size:13px;
      color:var(--muted);
      font-weight:800;
    }

    .load-hint{
      display:none;
      margin-right:10px;
      font-size:18px;
      font-weight:430;
      color:#7a5a26;
      letter-spacing:-0.2px;
      align-items:center;
      gap:8px;
      white-space:nowrap;
    }
    .load-hint .arrow{
      font-size:20px;
      font-weight:900;
      animation: arrowMove 1s infinite;
      display:inline-block;
    }
    @keyframes arrowMove{
      0%{ transform:translateX(0); opacity:0.55; }
      50%{ transform:translateX(7px); opacity:1; }
      100%{ transform:translateX(0); opacity:0.55; }
    }

    .blink{ animation: blinkPulse 1.2s infinite; }
    @keyframes blinkPulse{
      0%{ transform:translateY(0); box-shadow: 0 10px 16px rgba(243,214,161,0.14); }
      50%{ transform:translateY(-1px); box-shadow: 0 14px 22px rgba(243,214,161,0.20); }
      100%{ transform:translateY(0); box-shadow: 0 10px 16px rgba(243,214,161,0.14); }
    }

    .status{
      display:none;
      position: sticky;
      top: 12px;
      z-index: 50;
      margin:10px 0 12px;
      padding:12px 14px;
      border-radius:16px;
      border:1px solid var(--line);
      background: rgba(255,255,255,0.92);
      backdrop-filter: blur(6px);
      color:#111827;
      white-space:pre-wrap;
      font-size:16px;
      cursor:pointer;
    }
    .status.success{ border-color:#c7f3dd; background:#effdf7; color:#14532d; }
    .status.error{ border-color:#fecdd3; background:#fff1f2; color:#7f1d1d; }
    .status.loading{ background:#fbf4e6; color:#4b5563; }

    /* Grid box head: tabs at top-left */
    .grid-head{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      margin-bottom:10px;
    }
    .tabs{
      display:inline-flex;
      background:#f7f2e8;
      border:1px solid #e8e1d2;
      border-radius:999px;
      padding:4px;
      gap:4px;
      box-shadow: inset 0 1px 0 rgba(15,23,42,0.03);
    }
    .tab-btn{
      border:0;
      background:transparent;
      cursor:pointer;
      padding:10px 14px;
      border-radius:999px;
      font-weight:950;
      font-size:15px;
      color:#2b1f09;
      transition:0.18s;
      min-width:120px;
    }
    .tab-btn:disabled{ opacity:0.55; cursor:not-allowed; }
    .tab-btn.active{
      background: linear-gradient(180deg, rgba(255,242,214,0.98), rgba(243,214,161,0.88));
      box-shadow: 0 10px 16px rgba(243,214,161,0.12);
      border:1px solid rgba(234,200,139,0.40);
    }
    .grid-meta{
      font-size:13px;
      color:var(--muted);
      font-weight:850;
      white-space:nowrap;
    }

    #hotContainer{
      width:100%;
      height:560px;
      border:1px solid var(--line);
      border-radius:16px;
      overflow:hidden;
      background:#fff;
    }
    .hot-row-highlight{
      background: rgba(243,214,161,0.26) !important;
    }

    /* Modal (failure log) */
    .modal-backdrop{
      position:fixed;
      inset:0;
      background: rgba(2,6,23,0.38);
      display:none;
      align-items:center;
      justify-content:center;
      padding:18px;
      z-index:9999;
    }
    .modal{
      width:100%;
      max-width:1080px;
      background:#fff;
      border-radius:20px;
      border:1px solid var(--line);
      box-shadow: 0 22px 70px rgba(2,6,23,0.30);
      overflow:hidden;
    }
    .modal-head{
      padding:14px 16px;
      border-bottom:1px solid var(--line);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      background: linear-gradient(180deg, rgba(243,214,161,0.10), #fff);
    }
    .modal-title{
      font-size:17px;
      font-weight:950;
      margin:0;
    }
    .modal-body{
      padding:14px 16px;
      color:#0f172a;
      font-size:15px;
      line-height:1.5;
      max-height:70vh;
      overflow:auto;
    }
    .modal-foot{
      padding:14px 16px;
      border-top:1px solid var(--line);
      display:flex;
      justify-content:flex-end;
      gap:10px;
    }

    table.q{
      width:100%;
      border-collapse:separate;
      border-spacing:0;
      overflow:hidden;
      border:1px solid var(--line);
      border-radius:16px;
      background:#fff;
    }
    table.q th, table.q td{
      border-bottom:1px solid var(--line);
      padding:10px 12px;
      font-size:14px;
      text-align:left;
      vertical-align:middle;
    }
    table.q th{
      background:#f7f2e8;
      font-weight:950;
    }
    table.q tr:nth-child(even) td{ background: rgba(255,242,214,0.22); }
    table.q tr:last-child td{ border-bottom:none; }
    .danger{ color:var(--danger); font-weight:900; }

    @media (prefers-reduced-motion: reduce){
      .blink, .load-hint .arrow{ animation:none !important; }
      .btn:hover{ transform:none; }
      .icon-btn:hover{ transform:none; }
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="header">
      <div class="header-left">
        <h1 class="title">울산하늘공원 데이터 관리자</h1>
        <div class="badges">
          <span id="badgeOwner" class="badge hidden">Owner: <b>-</b></span>
          <span id="badgeRepo"  class="badge hidden">Repo: <b>-</b></span>
          <span id="badgeLoadedAt" class="badge hidden">마지막 로드: <b>-</b></span>
          <span id="badgeLoadedFiles" class="badge hidden">로드 파일: <b>-</b></span>
        </div>
      </div>
      <div class="header-right">
        <img class="logo" src="./images/ulsan_logo1.png" alt="울산 로고" />
      </div>
    </div>

    <div class="content">
      <!-- GitHub 설정 -->
      <div class="box">
        <div class="box-title">
          <span>GitHub 설정</span>
          <span class="hint-mini">‘불러오기’는 2개 파일(추모의집/자연장지)을 모두 로드</span>
        </div>

        <div class="row">
          <div class="form-group">
            <label>GitHub Owner</label>
            <input type="text" id="owner" placeholder="예: UL-SkyPark" />
          </div>
          <div class="form-group">
            <label>Repository</label>
            <input type="text" id="repo" placeholder="예: ulsan-skypark-search" />
          </div>
          <div class="form-group">
            <label>Access Token</label>
            <div class="input-with-btn">
              <input type="password" id="token" placeholder="ghp_... 또는 fine-grained token" />
              <button type="button" class="icon-btn" onclick="toggleToken()">보기</button>
            </div>
            <div class="field-help">fine-grained token이면 Contents 권한(읽기/쓰기) 확인해줘.</div>
          </div>
        </div>

        <div class="toolbar">
          <div id="loadHint" class="load-hint">
            먼저 ‘불러오기(2개 파일)’를 눌러주세요.
            <span class="arrow">→</span>
          </div>
          <button id="loadBtn" class="btn btn-primary" onclick="loadAllFiles()">불러오기</button>
        </div>
      </div>

      <!-- 상태 -->
      <div id="statusMsg" class="status" title="클릭하면 닫혀요"></div>

      <!-- 일괄등록 -->
      <div class="box">
        <div class="box-title">
          <span>일괄등록</span>
          <span class="hint-mini">업로드 반영 = 자동 분류 + 즉시 저장(2개 파일)</span>
        </div>

        <div class="row">
          <div class="form-group">
            <label>업로드 엑셀 선택(여러 개 가능)</label>
            <input type="file" id="bulkFile" accept=".xlsx,.xls" multiple />
            <div class="field-help">여러 파일을 동시에 선택하면 모두 합쳐서 자동 분류/저장됩니다.</div>
          </div>
        </div>

        <div class="toolbar">
          <button class="btn btn-ghost" id="bulkResetBtn" onclick="resetBulkUpload()" disabled>업로드 초기화</button>
          <button class="btn btn-primary" id="bulkBtn" onclick="importBulkExcelAutoSave()" disabled>업로드 반영</button>
        </div>
      </div>

      <!-- 그리드(불러온 엑셀) -->
      <div id="afterLoad" class="box" style="display:none;">
        <div class="grid-head">
          <div class="tabs" aria-label="대상 탭">
            <button id="tabDeceased" class="tab-btn active" onclick="selectTarget('deceased')">추모의집</button>
            <button id="tabNature" class="tab-btn" onclick="selectTarget('nature')">자연장지</button>
          </div>
          <div class="grid-meta" id="gridMeta">최근 20건 표시</div>
        </div>

        <div id="hotContainer"></div>
      </div>
    </div>
  </div>

  <!-- Failure Log Modal -->
  <div id="logModalBackdrop" class="modal-backdrop" role="dialog" aria-modal="true">
    <div class="modal">
      <div class="modal-head">
        <div class="modal-title" id="logModalTitle">업로드 실패 로그</div>
        <button class="btn btn-ghost" style="padding:8px 12px;" onclick="closeLogModal()">닫기</button>
      </div>
      <div class="modal-body" id="logModalBody"></div>
      <div class="modal-foot">
        <button class="btn btn-primary" onclick="closeLogModal()">확인</button>
      </div>
    </div>
  </div>

  <script>
    // ===== 설정 =====
    const BRANCH = "main";
    const FILES = {
      deceased: "data/deceased_data.xlsx",
      nature: "data/nature_data.xlsx"
    };
    const GRID_LIMIT = 20;

    // ===== 상태 =====
    let hot = null;
    let fileKey = "deceased";
    let isBusy = false;
    let isLoaded = false;
    let loadedAtText = "";

    // 실패 로그(모달 전용)
    let importFailLog = [];

    // 판별 실패 힌트(사유에 포함)
    const DETECT_HINT = [
      "힌트(번호 규칙):",
      " - 추모의집: '...추모의집-62실-개인단-21908' (실/추모의집 포함, 끝 5자리 숫자)",
      " - 자연장지: '잔디장-2-9-0108' (잔디장/수목장/자연장 등 포함, 끝 4자리 숫자)",
      "판별 규칙(요약):",
      " - '추모의집' 또는 '00실' 포함 → 추모의집",
      " - '잔디장/수목장/자연장' 포함 또는 '이름-숫자-숫자-4자리' 형태 → 자연장지",
      " - 끝자리 숫자 5자리 → 추모의집 / 4자리 → 자연장지(보조)"
    ].join("\n");

    // 데이터셋(2개 파일 동시 관리)
    const DATASETS = {
      deceased: {
        label: "추모의집",
        path: FILES.deceased,
        loaded: false,
        sha: "",
        headers: [],
        rows: [],
        highlight: new Set(),
      },
      nature: {
        label: "자연장지",
        path: FILES.nature,
        loaded: false,
        sha: "",
        headers: [],
        rows: [],
        highlight: new Set(),
      }
    };
    const ds = (k = fileKey) => DATASETS[k];

    window.onload = () => {
      const savedOwner = localStorage.getItem("gh_owner");
      const savedRepo  = localStorage.getItem("gh_repo");
      const savedToken = localStorage.getItem("gh_token");
      const savedTarget = localStorage.getItem("gh_target");
      const savedLoadedAt = localStorage.getItem("gh_loaded_at");

      if (savedOwner) document.getElementById("owner").value = savedOwner;
      if (savedRepo)  document.getElementById("repo").value  = savedRepo;
      if (savedToken) document.getElementById("token").value = savedToken;
      if (savedTarget === "nature") fileKey = "nature";

      selectTarget(fileKey, true);
      setLoaded(false);
      updateTopBadges(false, savedLoadedAt || "", "");

      ["owner","repo","token"].forEach(id=>{
        const el = document.getElementById(id);
        el?.addEventListener("keydown", (e)=>{
          if(e.key === "Enter") loadAllFiles();
        });
      });

      document.getElementById("statusMsg")?.addEventListener("click", ()=>{
        const el = document.getElementById("statusMsg");
        el.style.display = "none";
      });
    };

    function toggleToken(){
      const input = document.getElementById("token");
      const btn = document.querySelector(".icon-btn");
      if(!input || !btn) return;

      const isPw = input.type === "password";
      input.type = isPw ? "text" : "password";
      btn.textContent = isPw ? "가리기" : "보기";
    }

    // ===== 날짜/시간 =====
    function pad2(n){ return String(n).padStart(2,"0"); }
    function formatLoadedAt(d){
      const yyyy = d.getFullYear();
      const mm = pad2(d.getMonth()+1);
      const dd = pad2(d.getDate());
      const hh = pad2(d.getHours());
      const mi = pad2(d.getMinutes());
      return `${yyyy}-${mm}-${dd} ${hh}:${mi}`;
    }

    // ===== 로드 상태 UI =====
    function setLoaded(v){
      isLoaded = v;
      document.getElementById("afterLoad").style.display = v ? "block" : "none";
      showLoadHint(!v);

      const loadBtn = document.getElementById("loadBtn");
      loadBtn.classList.toggle("blink", !v);

      document.getElementById("bulkResetBtn").disabled = !v;
      document.getElementById("bulkBtn").disabled = !v || isBusy;

      document.getElementById("tabDeceased").disabled = !v || isBusy;
      document.getElementById("tabNature").disabled = !v || isBusy;

      setBusy(isBusy);
    }

    function showLoadHint(show){
      const el = document.getElementById("loadHint");
      el.style.display = show ? "inline-flex" : "none";
    }

    function updateTopBadges(show, loadedAt, loadedFilesText){
      const owner = document.getElementById("owner").value.trim();
      const repo  = document.getElementById("repo").value.trim();

      const bOwner = document.getElementById("badgeOwner");
      const bRepo  = document.getElementById("badgeRepo");
      const bLoaded= document.getElementById("badgeLoadedAt");
      const bFiles = document.getElementById("badgeLoadedFiles");

      if (!show){
        bOwner.classList.add("hidden");
        bRepo.classList.add("hidden");
        bLoaded.classList.add("hidden");
        bFiles.classList.add("hidden");
        return;
      }

      bOwner.querySelector("b").textContent = owner || "-";
      bRepo.querySelector("b").textContent  = repo  || "-";
      bLoaded.querySelector("b").textContent = loadedAt || "-";
      bFiles.querySelector("b").textContent  = loadedFilesText || "-";

      bOwner.classList.remove("hidden");
      bRepo.classList.remove("hidden");
      bLoaded.classList.remove("hidden");
      bFiles.classList.remove("hidden");
    }

    // ===== 상태 =====
    function showStatus(msg, type) {
      const el = document.getElementById("statusMsg");
      el.textContent = msg + (type === "loading" ? "\n(클릭하면 닫힘)" : "");
      el.className = "status " + type;
      el.style.display = "block";
      if (type === "success") setTimeout(() => (el.style.display = "none"), 2400);
    }

    function setBusy(b) {
      isBusy = b;
      document.getElementById("loadBtn").disabled = b;
      document.getElementById("bulkBtn").disabled = b || !isLoaded;
      document.getElementById("bulkResetBtn").disabled = b || !isLoaded;

      document.getElementById("tabDeceased").disabled = b || !isLoaded;
      document.getElementById("tabNature").disabled = b || !isLoaded;
    }

    // ===== 탭 변경 =====
    function selectTarget(target, isInit=false) {
      fileKey = target;
      localStorage.setItem("gh_target", fileKey);

      document.getElementById("tabDeceased").classList.toggle("active", fileKey === "deceased");
      document.getElementById("tabNature").classList.toggle("active", fileKey === "nature");

      const meta = document.getElementById("gridMeta");
      meta.textContent = `${ds(fileKey).label} · 최근 20건 표시`;

      if (isLoaded) renderGridForCurrentTarget(false);
      if (!isInit && isLoaded) updateTopBadges(true, loadedAtText, "추모의집 + 자연장지");
    }

    // ===== 입력값 =====
    function getInputs() {
      const owner = document.getElementById("owner").value.trim();
      const repo  = document.getElementById("repo").value.trim();
      const token = document.getElementById("token").value.trim();
      return { owner, repo, token, branch: BRANCH };
    }

    function saveInputsToLocalStorage({owner, repo, token}) {
      localStorage.setItem("gh_owner", owner);
      localStorage.setItem("gh_repo", repo);
      localStorage.setItem("gh_token", token);
    }

    function buildContentsUrl(owner, repo, path, branch) {
      return `https://api.github.com/repos/${owner}/${repo}/contents/${encodeURI(path)}?ref=${encodeURIComponent(branch)}`;
    }

    // ===== 유틸 =====
    function norm(s) {
      return String(s ?? "")
        .replace(/\s+/g, "")
        .replace(/[–—]/g, "-")
        .toLowerCase();
    }
    function escapeHtml(s) {
      return String(s ?? "")
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }
    function escapeHtmlWithBr(s){
      return escapeHtml(s).replaceAll("\n","<br>");
    }
    function normalizeDate(input) {
      const raw = String(input ?? "").trim();
      if (!raw) return "";
      const onlyNum = raw.replace(/[^0-9]/g, "");
      if (onlyNum.length === 8) {
        const y = onlyNum.slice(0,4), m = onlyNum.slice(4,6), d = onlyNum.slice(6,8);
        return `${y}-${m}-${d}`;
      }
      const cleaned = raw.replace(/\./g, "-").replace(/\//g, "-");
      const parts = cleaned.split("-").map(p => p.trim()).filter(Boolean);
      if (parts.length >= 3) {
        let [y,m,d] = parts;
        if (y.length === 2) y = "20" + y;
        m = String(parseInt(m,10)).padStart(2,"0");
        d = String(parseInt(d,10)).padStart(2,"0");
        if (!/^\d{4}$/.test(y) || m === "NaN" || d === "NaN") return "";
        return `${y}-${m}-${d}`;
      }
      return "";
    }
    function findHeaderIndex(hs, candidates) {
      const list = hs.map(norm);
      for (const cand of candidates) {
        const idx = list.indexOf(norm(cand));
        if (idx !== -1) return idx;
      }
      return -1;
    }
    function uint8ArrayToBase64(u8) {
      let binary = "";
      const chunkSize = 0x8000;
      for (let i = 0; i < u8.length; i += chunkSize) {
        const chunk = u8.subarray(i, i + chunkSize);
        binary += String.fromCharCode.apply(null, chunk);
      }
      return btoa(binary);
    }
    function getCellByHeader(rowObj, candidates) {
      const keys = Object.keys(rowObj || {});
      const map = new Map(keys.map(k => [norm(k), k]));
      for (const c of candidates) {
        const key = map.get(norm(c));
        if (key !== undefined) return rowObj[key];
      }
      return "";
    }
    function isRowEffectivelyEmpty(rowObj){
      if (!rowObj) return true;
      const vals = Object.values(rowObj);
      if (!vals.length) return true;
      return vals.every(v => String(v ?? "").trim() === "");
    }

    function noHeaderCandidatesFor(key){
      return (key === "deceased")
        ? ["봉안번호","봉안 번호","봉안no","봉안No","번호","관리번호"]
        : ["자연장번호","자연장 번호","자연장no","자연장No","번호","관리번호"];
    }

    // ===== 업로드 초기화 =====
    function resetBulkUpload(){
      const input = document.getElementById("bulkFile");
      if (input) input.value = "";
      showStatus("업로드 파일 선택이 초기화되었습니다.", "success");
    }

    // ===== 모달(실패 로그) =====
    function openLogModal(title, html){
      document.getElementById("logModalTitle").textContent = title;
      document.getElementById("logModalBody").innerHTML = html;
      document.getElementById("logModalBackdrop").style.display = "flex";
    }
    function closeLogModal(){
      document.getElementById("logModalBackdrop").style.display = "none";
    }
    document.getElementById("logModalBackdrop")?.addEventListener("click", (e) => {
      if (e.target.id === "logModalBackdrop") closeLogModal();
    });

    function buildFailLogTable(){
      if (!importFailLog.length){
        return `<div style="color:var(--muted); font-weight:850;">실패 로그가 없습니다.</div>`;
      }

      let html = `<table class="q"><thead><tr>
        <th style="width:160px;">파일</th>
        <th style="width:90px;">엑셀행</th>
        <th style="width:120px;">대상</th>
        <th style="width:90px;">구분</th>
        <th>번호</th>
        <th>사망자명</th>
        <th>신청자명</th>
        <th>사유</th>
      </tr></thead><tbody>`;

      for (const l of importFailLog){
        html += `<tr>
          <td><b>${escapeHtml(l.file || "-")}</b></td>
          <td>${escapeHtml(l.rowNo)}</td>
          <td><b>${escapeHtml(l.target || "-")}</b></td>
          <td>${escapeHtml(l.kind || "-")}</td>
          <td><b>${escapeHtml(l.no || "")}</b></td>
          <td>${escapeHtml(l.deceased || "")}</td>
          <td>${escapeHtml(l.applicant || "")}</td>
          <td class="danger">${escapeHtmlWithBr(l.reason || "")}</td>
        </tr>`;
      }
      html += `</tbody></table>`;
      return html;
    }

    // ===== GitHub fetch (xlsx) =====
    async function fetchXlsxFromGitHub({owner, repo, token, branch}, path){
      const apiUrl = buildContentsUrl(owner, repo, path, branch);

      const metaRes = await fetch(apiUrl, {
        headers: { "Authorization": `Bearer ${token}`, "Accept": "application/vnd.github+json" }
      });
      if (!metaRes.ok) {
        const txt = await metaRes.text();
        throw new Error(`메타 조회 실패: ${path} (${metaRes.status})\n${txt}`);
      }
      const meta = await metaRes.json();
      if (Array.isArray(meta)) throw new Error(`경로가 폴더로 인식됨: ${path}`);
      if (!meta.download_url) throw new Error(`download_url 없음: ${path}`);

      const fileRes = await fetch(meta.download_url);
      if (!fileRes.ok) {
        const txt = await fileRes.text();
        throw new Error(`다운로드 실패: ${path} (${fileRes.status})\n${txt}`);
      }

      const buf = await fileRes.arrayBuffer();
      const bytes = new Uint8Array(buf);

      const wb = XLSX.read(bytes, { type: "array" });
      const ws = wb.Sheets[wb.SheetNames[0]];
      const aoa = XLSX.utils.sheet_to_json(ws, { header: 1, defval: "" });

      return { sha: meta.sha || "", aoa };
    }

    function normalizeLoadedDataset(key, aoa){
      const d = ds(key);
      d.headers = (aoa && aoa.length > 0) ? aoa[0].map(h => String(h ?? "").trim()) : [];
      d.rows = (aoa && aoa.length > 1) ? aoa.slice(1) : [];

      // 추모의집: 반환일자 컬럼 없으면 생성
      if (key === "deceased") {
        const idxReturn = findHeaderIndex(d.headers, ["반환일자","반환 일자","반환일"]);
        if (idxReturn === -1) d.headers.push("반환일자");
        for (const row of d.rows) while (row.length < d.headers.length) row.push("");
      }

      d.highlight = new Set();
      d.loaded = true;
    }

    // ===== 그리드 =====
    function renderGridForCurrentTarget(scrollInto=false){
      const cur = ds(fileKey);
      const container = document.getElementById("hotContainer");
      container.innerHTML = "";

      const headers = cur.headers || [];
      const rows = cur.rows || [];
      const viewRows = rows.slice(-GRID_LIMIT);

      if (hot) { hot.destroy(); hot = null; }

      hot = new Handsontable(container, {
        data: viewRows,
        rowHeaders: true,
        colHeaders: headers,
        height: 560,
        width: "100%",
        stretchH: "all",
        licenseKey: "non-commercial-and-evaluation",
        readOnly: true,
        contextMenu: false,
        manualColumnResize: true,
        manualRowResize: true,
        filters: true,
        dropdownMenu: true,
        cells: function (row, col) {
          const props = {};
          const startGlobal = Math.max(0, rows.length - GRID_LIMIT);
          const globalIdx = startGlobal + row;
          if (cur.highlight.has(globalIdx)) {
            props.className = (props.className ? props.className + " " : "") + "hot-row-highlight";
          }
          return props;
        }
      });

      setTimeout(() => { hot.render(); hot.refreshDimensions(); }, 0);
      if (scrollInto) container.scrollIntoView({ behavior:"smooth", block:"start" });
    }

    // ===== 불러오기(2개 파일) =====
    async function loadAllFiles() {
      const inputs = getInputs();
      const { owner, repo, token } = inputs;
      if (!owner || !repo || !token) {
        showStatus("Owner / Repo / Token을 모두 입력해 주세요.", "error");
        setLoaded(false);
        return;
      }

      saveInputsToLocalStorage({owner, repo, token});
      setBusy(true);
      showStatus("2개 파일(추모의집/자연장지)을 불러오는 중...", "loading");

      try {
        DATASETS.deceased.loaded = false;
        DATASETS.nature.loaded = false;

        const tasks = [
          fetchXlsxFromGitHub(inputs, DATASETS.deceased.path).then(res => ({ key:"deceased", ...res })),
          fetchXlsxFromGitHub(inputs, DATASETS.nature.path).then(res => ({ key:"nature", ...res }))
        ];

        const results = await Promise.allSettled(tasks);

        const errors = [];
        for (const r of results){
          if (r.status === "rejected") errors.push(r.reason?.message || String(r.reason));
          else {
            const { key, sha, aoa } = r.value;
            ds(key).sha = sha;
            normalizeLoadedDataset(key, aoa);
          }
        }

        if (errors.length){
          setLoaded(false);
          throw new Error("로드 실패:\n" + errors.join("\n\n"));
        }

        const now = new Date();
        loadedAtText = formatLoadedAt(now);
        localStorage.setItem("gh_loaded_at", loadedAtText);

        setLoaded(true);
        updateTopBadges(true, loadedAtText, "추모의집 + 자연장지");
        showStatus("로드 완료. (2개 파일)", "success");

        const meta = document.getElementById("gridMeta");
        meta.textContent = `${ds(fileKey).label} · 최근 20건 표시`;
        renderGridForCurrentTarget(true);

      } catch (e) {
        setLoaded(false);
        showStatus(e.message || String(e), "error");
      } finally {
        setBusy(false);
      }
    }

    // ===== 번호 패턴으로 대상 판별 =====
    function detectTargetByNo(noRaw){
      const s = String(noRaw ?? "").trim();
      if (!s) return null;

      // 1) 명시 키워드
      if (s.includes("추모의집")) return "deceased";
      if (s.includes("잔디장") || s.includes("수목장") || s.includes("자연장")) return "nature";

      // 2) 'xx실' 패턴
      if (/-\d{1,3}실-/.test(s) || /\b\d{1,3}실\b/.test(s) || /\d{1,3}실/.test(s)) return "deceased";

      // 3) 자연장 예시 형태(이름-숫자-숫자-4자리)
      if (/^[^-]+-\d+-\d+-\d{4}$/.test(s)) return "nature";

      // 4) 끝자리 숫자 길이(보조)
      const m = s.match(/(\d+)\s*$/);
      if (m){
        const len = m[1].length;
        if (len === 5) return "deceased";
        if (len === 4) return "nature";
      }

      return null;
    }

    // ===== 중복 체크 =====
    function isDuplicateNoInExcel(targetKey, noVal, rowsOverride=null, headersOverride=null) {
      const d = ds(targetKey);
      const rows = rowsOverride || d.rows;
      const headers = headersOverride || d.headers;

      const v = norm(noVal);
      if (!v) return false;

      const idxNo = findHeaderIndex(headers, noHeaderCandidatesFor(targetKey));
      if (idxNo === -1) throw new Error((targetKey === "deceased" ? "봉안번호" : "자연장번호") + " 헤더를 찾을 수 없습니다.");

      for (const row of rows) {
        if (norm(row[idxNo]) === v) return true;
      }
      return false;
    }

    // ===== 반환: 완전일치 찾기(추모의집) =====
    function findExactMatchRowDeceased(noVal, deceasedVal, applicantVal, rowsOverride=null, headersOverride=null) {
      const d = ds("deceased");
      const rows = rowsOverride || d.rows;
      const headers = headersOverride || d.headers;

      const idxNo = findHeaderIndex(headers, ["봉안번호","봉안 번호","봉안no","봉안No","번호","관리번호"]);
      const idxDe = findHeaderIndex(headers, ["사망자명","고인명","고인","사망자"]);
      const idxAp = findHeaderIndex(headers, ["신청자명","신청자","사용자명","계약자명"]);
      const idxReturn = findHeaderIndex(headers, ["반환일자","반환 일자","반환일"]);

      const missing = [];
      if (idxNo === -1) missing.push("봉안번호");
      if (idxDe === -1) missing.push("사망자명");
      if (idxAp === -1) missing.push("신청자명");
      if (idxReturn === -1) missing.push("반환일자");
      if (missing.length) throw new Error("헤더를 찾을 수 없습니다: " + missing.join(", "));

      const noN = norm(noVal), deN = norm(deceasedVal), apN = norm(applicantVal);

      for (let r = 0; r < rows.length; r++) {
        const row = rows[r];
        if (norm(row[idxNo]) === noN && norm(row[idxDe]) === deN && norm(row[idxAp]) === apN) {
          const hasReturn = String(row[idxReturn] ?? "").trim() !== "";
          return { found:true, rowIndex:r, idxReturn, hasReturn };
        }
      }
      return { found:false };
    }

    // ===== 저장: GitHub PUT =====
    async function putToGitHub(targetKey, mergedAoa, message) {
      const inputs = getInputs();
      const { owner, repo, token, branch } = inputs;
      const d = ds(targetKey);

      const apiUrl = buildContentsUrl(owner, repo, d.path, branch);

      const ws = XLSX.utils.aoa_to_sheet(mergedAoa);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, "Sheet1");

      const wbOut = XLSX.write(wb, { bookType: "xlsx", type: "array" });
      const bytes = new Uint8Array(wbOut);
      const contentBase64 = uint8ArrayToBase64(bytes);

      const putBody = { message, content: contentBase64, sha: d.sha, branch };

      const res = await fetch(apiUrl, {
        method: "PUT",
        headers: {
          "Authorization": `Bearer ${token}`,
          "Accept": "application/vnd.github+json",
          "Content-Type": "application/json"
        },
        body: JSON.stringify(putBody)
      });

      if (!res.ok) {
        const txt = await res.text();
        throw new Error(`[${d.label}] 저장 실패 (${res.status})\n${txt}`);
      }

      const resData = await res.json();
      d.sha = resData.content?.sha || d.sha;
    }

    // ===== 업로드 반영: 자동 분류 + 즉시 저장(대기목록 없음) =====
    async function importBulkExcelAutoSave() {
      if (!isLoaded) {
        showLoadHint(true);
        setLoaded(false);
        showStatus("먼저 ‘불러오기(2개 파일)’를 눌러주세요.", "error");
        return;
      }
      if (isBusy) return;

      const input = document.getElementById("bulkFile");
      if (!input || !input.files || input.files.length === 0) {
        showStatus("업로드할 엑셀 파일을 선택해 주세요.", "error");
        return;
      }

      setBusy(true);
      showStatus("업로드 분석 → 자동 분류 → 즉시 저장 중...", "loading");

      try {
        // 실패 로그 초기화(이번 업로드 기준)
        importFailLog = [];

        // 변경분 수집
        const adds = { deceased: [], nature: [] }; // 신규 append
        const rets = []; // 추모의집 반환

        // 업로드 내부 중복 방지(여러 파일 합산)
        const uploadNoSet = { deceased: new Set(), nature: new Set() };
        const uploadRetKeySet = new Set();

        let processed = 0;

        // ✅ 여러 파일 처리
        const files = Array.from(input.files);

        for (const file of files){
          const buf = await file.arrayBuffer();
          const wb = XLSX.read(new Uint8Array(buf), { type: "array" });

          const ws = wb.Sheets[wb.SheetNames[0]];
          const rowsObj = XLSX.utils.sheet_to_json(ws, { defval: "" });

          if (!rowsObj || rowsObj.length === 0){
            // 파일 자체가 비었으면 로그에만 남김(원하면 스킵 가능)
            importFailLog.push({ file:file.name, rowNo:"-", target:"-", kind:"-", no:"", deceased:"", applicant:"", reason:"업로드 엑셀에 데이터가 없습니다." });
            continue;
          }

          for (let i = 0; i < rowsObj.length; i++) {
            const r = rowsObj[i];
            const rowNo = i + 2; // 헤더 1행 가정

            // ✅ "항상 비어있는 줄" 예외 처리: 빈 행은 그냥 스킵(로그도 안 남김)
            if (isRowEffectivelyEmpty(r)) continue;

            processed++;

            const noRaw = String(getCellByHeader(r, ["봉안번호","봉안 번호","자연장번호","자연장 번호","번호","관리번호"])).trim();
            const deceased = String(getCellByHeader(r, ["사망자명","고인명","고인","사망자"])).trim();
            const applicant = String(getCellByHeader(r, ["신청자명","신청자","사용자명","계약자명"])).trim();
            const inDateRaw = String(getCellByHeader(r, ["안치일자","안치 일자","안치일"])).trim();
            const returnRaw = String(getCellByHeader(r, ["반환일자","반환 일자","반환일"])).trim();

            if (!noRaw){
              importFailLog.push({ file:file.name, rowNo, target:"-", kind:"-", no:noRaw, deceased, applicant, reason:"번호(봉안/자연장)가 누락되었습니다." });
              continue;
            }

            const targetKey = detectTargetByNo(noRaw);
            if (!targetKey){
              importFailLog.push({
                file:file.name,
                rowNo,
                target:"판별실패",
                kind:"-",
                no:noRaw,
                deceased,
                applicant,
                reason: "번호 패턴으로 대상(추모의집/자연장지) 판별에 실패했습니다.\n" + DETECT_HINT
              });
              continue;
            }
            const targetLabel = ds(targetKey).label;

            const isReturn = !!String(returnRaw).trim();
            const kind = isReturn ? "반환" : "신규";

            // 반환
            if (isReturn){
              if (targetKey !== "deceased"){
                importFailLog.push({ file:file.name, rowNo, target:targetLabel, kind, no:noRaw, deceased, applicant, reason:"자연장지는 반환 처리가 불가합니다." });
                continue;
              }
              if (!deceased || !applicant){
                importFailLog.push({ file:file.name, rowNo, target:targetLabel, kind, no:noRaw, deceased, applicant, reason:"필수값 누락(사망자명/신청자명)으로 반환 처리 불가." });
                continue;
              }
              const returnDate = normalizeDate(returnRaw);
              if (!returnDate){
                importFailLog.push({ file:file.name, rowNo, target:targetLabel, kind, no:noRaw, deceased, applicant, reason:"반환일자 형식이 올바르지 않습니다." });
                continue;
              }

              const key3 = norm(noRaw) + "|" + norm(deceased) + "|" + norm(applicant);
              if (uploadRetKeySet.has(key3)){
                importFailLog.push({ file:file.name, rowNo, target:targetLabel, kind, no:noRaw, deceased, applicant, reason:"업로드 파일 내 반환 항목 중복(번호/사망자/신청자)." });
                continue;
              }
              uploadRetKeySet.add(key3);

              rets.push({ file:file.name, rowNo, no:noRaw, deceased, applicant, returnDate });
              continue;
            }

            // 신규
            if (!deceased || !applicant){
              importFailLog.push({ file:file.name, rowNo, target:targetLabel, kind, no:noRaw, deceased, applicant, reason:"필수값이 누락되었습니다(사망자명/신청자명)." });
              continue;
            }
            if (!inDateRaw){
              importFailLog.push({ file:file.name, rowNo, target:targetLabel, kind, no:noRaw, deceased, applicant, reason:"안치일자가 누락되었습니다(신규)." });
              continue;
            }
            const inDate = normalizeDate(inDateRaw);
            if (!inDate){
              importFailLog.push({ file:file.name, rowNo, target:targetLabel, kind, no:noRaw, deceased, applicant, reason:"안치일자 형식이 올바르지 않습니다(신규)." });
              continue;
            }

            const vNo = norm(noRaw);
            if (uploadNoSet[targetKey].has(vNo)){
              importFailLog.push({ file:file.name, rowNo, target:targetLabel, kind, no:noRaw, deceased, applicant, reason:"업로드 파일(전체) 내 동일 번호 중복." });
              continue;
            }
            uploadNoSet[targetKey].add(vNo);

            adds[targetKey].push({ file:file.name, rowNo, inDate, no:noRaw, deceased, applicant });
          }
        }

        if (processed === 0){
          showStatus("업로드 파일에 처리할 데이터가 없습니다(빈 행만 존재).", "error");
          return;
        }

        // ===== 변경 적용(로컬 복사본) =====
        const next = {
          deceased: { headers: ds("deceased").headers.slice(), rows: ds("deceased").rows.map(r=>r.slice()), highlight: new Set() },
          nature:   { headers: ds("nature").headers.slice(),   rows: ds("nature").rows.map(r=>r.slice()),   highlight: new Set() }
        };

        // 신규 append 적용
        const applyAdds = (key) => {
          if (!adds[key].length) return 0;
          const headers = next[key].headers;
          const rows = next[key].rows;

          const idxInDate = findHeaderIndex(headers, ["안치일자","안치 일자","안치일"]);
          const idxNo = findHeaderIndex(headers, noHeaderCandidatesFor(key));
          const idxDe = findHeaderIndex(headers, ["사망자명","고인명","고인","사망자"]);
          const idxAp = findHeaderIndex(headers, ["신청자명","신청자","사용자명","계약자명"]);

          const missing = [];
          if (idxInDate === -1) missing.push("안치일자");
          if (idxNo === -1) missing.push(key === "deceased" ? "봉안번호" : "자연장번호");
          if (idxDe === -1) missing.push("사망자명");
          if (idxAp === -1) missing.push("신청자명");
          if (missing.length) throw new Error(`[${ds(key).label}] 헤더를 찾을 수 없습니다: ${missing.join(", ")}`);

          // 저장 직전 중복(기존 파일 기준)
          const existSet = new Set();
          for (const row of rows){
            const vv = norm(row[idxNo]);
            if (vv) existSet.add(vv);
          }

          let added = 0;

          for (const q of adds[key]){
            const vv = norm(q.no);

            if (existSet.has(vv)){
              importFailLog.push({
                file:q.file, rowNo:q.rowNo,
                target:ds(key).label, kind:"신규",
                no:q.no, deceased:q.deceased, applicant:q.applicant,
                reason:"해당 대상 파일의 기존 번호와 중복됩니다."
              });
              continue;
            }
            existSet.add(vv);

            const row = new Array(headers.length).fill("");
            row[idxInDate] = q.inDate;
            row[idxNo] = q.no;
            row[idxDe] = q.deceased;
            row[idxAp] = q.applicant;

            rows.push(row);
            next[key].highlight.add(rows.length - 1);
            added++;
          }

          return added;
        };

        // 반환 적용(추모의집)
        const applyReturns = () => {
          if (!rets.length) return 0;

          const headers = next.deceased.headers;
          const rows = next.deceased.rows;

          let applied = 0;

          for (const q of rets){
            let match;
            try {
              match = findExactMatchRowDeceased(q.no, q.deceased, q.applicant, rows, headers);
            } catch (e) {
              importFailLog.push({ file:q.file, rowNo:q.rowNo, target:"추모의집", kind:"반환", no:q.no, deceased:q.deceased, applicant:q.applicant, reason:e.message || "헤더 확인 필요" });
              continue;
            }

            if (!match.found){
              importFailLog.push({ file:q.file, rowNo:q.rowNo, target:"추모의집", kind:"반환", no:q.no, deceased:q.deceased, applicant:q.applicant, reason:"기존 정보와 일치하는 행을 찾을 수 없습니다(완전일치 필요)." });
              continue;
            }
            if (match.hasReturn){
              importFailLog.push({ file:q.file, rowNo:q.rowNo, target:"추모의집", kind:"반환", no:q.no, deceased:q.deceased, applicant:q.applicant, reason:"이미 반환일자가 등록되어 있습니다." });
              continue;
            }

            rows[match.rowIndex][match.idxReturn] = q.returnDate;
            next.deceased.highlight.add(match.rowIndex);
            applied++;
          }

          return applied;
        };

        const addedDe = applyAdds("deceased");
        const addedNa = applyAdds("nature");
        const retDe = applyReturns();

        const needSaveDe = (addedDe > 0) || (retDe > 0);
        const needSaveNa = (addedNa > 0);

        if (!needSaveDe && !needSaveNa){
          showStatus("저장할 항목이 없습니다. (모두 실패/중복/판별실패)", "error");
          if (importFailLog.length){
            openLogModal("업로드 실패 로그", buildFailLogTable());
          }
          return;
        }

        // ===== GitHub 저장(2개 파일) =====
        const saveErrors = [];

        try {
          if (needSaveDe){
            const merged = [next.deceased.headers, ...next.deceased.rows];
            await putToGitHub("deceased", merged, `Auto upload save (deceased) new:${addedDe} return:${retDe} ${new Date().toISOString()}`);
          }
        } catch (e) {
          saveErrors.push(e.message || String(e));
        }

        try {
          if (needSaveNa){
            const merged = [next.nature.headers, ...next.nature.rows];
            await putToGitHub("nature", merged, `Auto upload save (nature) new:${addedNa} ${new Date().toISOString()}`);
          }
        } catch (e) {
          saveErrors.push(e.message || String(e));
        }

        if (saveErrors.length){
          showStatus("저장 중 오류가 발생했습니다.\n" + saveErrors.join("\n\n"), "error");
          return;
        }

        // ===== 로컬 반영 + 하이라이트 =====
        if (needSaveDe){
          ds("deceased").rows = next.deceased.rows;
          ds("deceased").highlight = next.deceased.highlight;
        }
        if (needSaveNa){
          ds("nature").rows = next.nature.rows;
          ds("nature").highlight = next.nature.highlight;
        }

        renderGridForCurrentTarget(false);

        const msg =
          `업로드 저장 완료\n` +
          `추모의집: 신규 ${addedDe} / 반환 ${retDe}\n` +
          `자연장지: 신규 ${addedNa}\n` +
          (importFailLog.length ? `실패 ${importFailLog.length}건(모달 확인)` : `실패 0건`);
        showStatus(msg, "success");

        if (importFailLog.length){
          openLogModal("업로드 실패 로그", buildFailLogTable());
        }

      } catch (e) {
        showStatus(e.message || String(e), "error");
      } finally {
        setBusy(false);
      }
    }
  </script>
</body>
</html>
