<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>울산하늘공원 데이터 관리자 (다중입력 + 반환등록 + 업로드 로그)</title>

  <!-- Handsontable -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/handsontable/dist/handsontable.full.min.css" />
  <script src="https://cdn.jsdelivr.net/npm/handsontable/dist/handsontable.full.min.js"></script>

  <!-- XLSX -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <style>
    body{
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;
      background:#f6f2ec; color:#2f2a25;
      padding:20px; margin:0;
      display:flex; flex-direction:column; align-items:center;
    }
    .container{
      background:#fff; padding:20px; border-radius:12px;
      box-shadow:0 4px 20px rgba(0,0,0,0.08);
      width:100%; max-width:1200px;
    }
    h1{ margin:0 0 12px; font-size:22px; color:#3a332e; text-align:center; }

    .row{ display:grid; grid-template-columns:repeat(auto-fit,minmax(240px,1fr)); gap:10px; margin-bottom:12px; }
    .box{
      background:#fafafa; padding:14px; border-radius:10px; border:1px solid #eee;
    }
    .box-title{ font-weight:950; margin-bottom:10px; color:#3a332e; }

    .form-group label{ display:block; font-weight:900; font-size:13px; margin-bottom:4px; color:#555; }
    .form-group input{
      width:100%; padding:9px; border:1px solid #dcdcdc; border-radius:8px; font-size:14px;
      box-sizing:border-box; background:#fff;
    }
    .mini{ font-size:12px; color:#777; margin-top:6px; line-height:1.4; }
    .mini b{ color:#333; }

    .toolbar{ display:flex; gap:10px; justify-content:flex-end; flex-wrap:wrap; margin-top:10px; }
    .btn{
      padding:10px 16px; border:none; border-radius:8px;
      font-size:14px; font-weight:950; cursor:pointer; transition:0.2s; white-space:nowrap;
    }
    .btn:disabled{ background:#ccc; cursor:not-allowed; }
    .btn-load{ background:#3a332e; color:#fff; }
    .btn-load:hover{ background:#524a42; }
    .btn-add{ background:#1f7aec; color:#fff; }
    .btn-add:hover{ background:#1966c6; }
    .btn-save{ background:#27ae60; color:#fff; }
    .btn-save:hover{ background:#219150; }
    .btn-clear{ background:#888; color:#fff; }
    .btn-clear:hover{ background:#6f6f6f; }

    .seg{
      display:flex; gap:10px; justify-content:center; margin-bottom:12px; flex-wrap:wrap;
    }
    .seg button{
      border:1px solid #dcdcdc; background:#fff; color:#3a332e;
      padding:10px 14px; border-radius:999px; font-weight:950; cursor:pointer;
    }
    .seg button.active{
      background:#3a332e; color:#fff; border-color:#3a332e;
    }

    #hotContainer{
      width:100%; height:560px; overflow:auto;
      border:1px solid #dcdcdc; border-radius:8px; background:#fff;
    }

    .status{
      margin:10px 0 12px; padding:10px; border-radius:8px; font-size:14px;
      text-align:center; display:none; white-space:pre-wrap;
    }
    .status.success{ background:#e0f5f0; color:#1d7c6b; }
    .status.error{ background:#fdeaea; color:#b92b27; }
    .status.loading{ background:#f0f0f0; color:#555; }

    .pill{
      display:inline-block; padding:3px 8px; border-radius:999px;
      font-size:12px; font-weight:900; border:1px solid #e3e3e3; background:#f3f3f3;
    }

    table.q{
      width:100%; border-collapse:collapse; background:#fff;
      border-radius:8px; overflow:hidden; border:1px solid #e6e6e6;
    }
    table.q th, table.q td{
      border-bottom:1px solid #eee; padding:10px; font-size:13px; text-align:left; vertical-align:middle;
    }
    table.q th{ background:#f7f7f7; font-weight:950; color:#333; }
    table.q tr:last-child td{ border-bottom:none; }

    .hint{
      margin-top:10px; font-size:12px; color:#777; line-height:1.45;
    }
    .hint code{ background:#f3f3f3; padding:2px 6px; border-radius:6px; }

    .danger{ color:#b92b27; font-weight:950; }
  </style>
</head>

<body>
  <div class="container">
    <h1>데이터 관리자 (다중입력 + 반환등록 + 업로드 로그)</h1>

    <!-- 대상 선택: 버튼 2개 -->
    <div class="seg">
      <button id="btnDeceased" class="active" onclick="selectTarget('deceased')">추모의집</button>
      <button id="btnNature" onclick="selectTarget('nature')">자연장지</button>
    </div>

    <!-- GitHub 설정 (3개만) -->
    <div class="box" style="margin-bottom:12px;">
      <div class="row" style="margin:0;">
        <div class="form-group">
          <label>GitHub Owner</label>
          <input type="text" id="owner" placeholder="예: UL-SkyPark" />
        </div>
        <div class="form-group">
          <label>Repository</label>
          <input type="text" id="repo" placeholder="예: ulsan-skypark-search" />
        </div>
        <div class="form-group">
          <label>Access Token</label>
          <input type="password" id="token" placeholder="ghp_... 또는 fine-grained token" />
        </div>
      </div>

      <div class="mini">
        * 그리드는 <b>조회만(읽기전용)</b> / 브랜치 <b>main</b> 고정<br/>
        * 로드: contents 메타 조회 → <b>download_url</b>로 xlsx 다운로드<br/>
        * 추모의집 파일은 “반환일자” 컬럼이 없으면 자동 생성
      </div>

      <div class="toolbar">
        <button id="loadBtn" class="btn btn-load" onclick="loadFile()">엑셀 불러오기</button>
      </div>
    </div>

    <!-- 업로드로 대기목록 채우기 -->
    <div class="box" style="margin-bottom:12px;">
      <div class="box-title">엑셀 업로드 → 대기목록 채우기</div>
      <div class="row" style="margin:0;">
        <div class="form-group">
          <label>업로드 엑셀 선택</label>
          <input type="file" id="bulkFile" accept=".xlsx,.xls" />
          <div class="mini">
            ✅ 업로드 엑셀 규칙: <b>반환일자</b>가 있으면 “반환”, 비어있으면 “신규”로 분류<br/>
            - 신규: 안치일자, (봉안번호/자연장번호), 사망자명, 신청자명<br/>
            - 반환(추모의집만): 봉안번호, 사망자명, 신청자명, 반환일자
          </div>
        </div>
      </div>
      <div class="toolbar">
        <button class="btn btn-add" id="bulkBtn" onclick="importBulkExcel()" disabled>업로드 반영</button>
        <button class="btn btn-clear" id="clearLogBtn" onclick="clearImportLog()" disabled>업로드 로그 비우기</button>
      </div>
    </div>

    <!-- 입력 영역 -->
    <div class="row">
      <!-- 신규 등록 -->
      <div class="box">
        <div class="box-title" id="newTitle">신규 등록 (추모의집)</div>

        <div class="row" style="margin-bottom:10px;">
          <div class="form-group">
            <label>안치일자</label>
            <input type="text" id="f_inDate" placeholder="예: 2026-02-18 / 20260218 / 2026.2.18" />
          </div>

          <div class="form-group">
            <label id="lblNoNew">봉안번호</label>
            <input type="text" id="f_no" placeholder="예: 1추모의집-62실-개인단-21903" />
          </div>

          <div class="form-group">
            <label>사망자명</label>
            <input type="text" id="f_deceased" placeholder="예: 홍길동" />
          </div>

          <div class="form-group">
            <label>신청자명</label>
            <input type="text" id="f_applicant" placeholder="예: 김철수" />
          </div>
        </div>

        <div class="toolbar">
          <button id="queueNewBtn" class="btn btn-add" onclick="queueNew()" disabled>신규대기 추가</button>
          <button id="saveNewBtn" class="btn btn-save" onclick="saveNewQueue()" disabled>신규대기 저장</button>
          <button id="clearNewBtn" class="btn btn-clear" onclick="clearNewQueue()" disabled>신규대기 비우기</button>
        </div>

        <div class="mini">
          ✅ 번호 중복 체크(엑셀 기존 + 신규대기) / 날짜 자동 정리(YYYY-MM-DD)
        </div>
      </div>

      <!-- 반환 등록 (추모의집만) -->
      <div class="box" id="returnBox">
        <div class="box-title">반환 등록 (추모의집 전용)</div>

        <div class="row" style="margin-bottom:10px;">
          <div class="form-group">
            <label>봉안번호</label>
            <input type="text" id="r_no" placeholder="예: 1추모의집-62실-개인단-21903" />
          </div>

          <div class="form-group">
            <label>사망자명</label>
            <input type="text" id="r_deceased" placeholder="예: 홍길동" />
          </div>

          <div class="form-group">
            <label>신청자명</label>
            <input type="text" id="r_applicant" placeholder="예: 김철수" />
          </div>

          <div class="form-group">
            <label>반환일자</label>
            <input type="text" id="r_returnDate" placeholder="예: 2026-03-01 / 20260301 / 2026.3.1" />
          </div>
        </div>

        <div class="toolbar">
          <button id="queueReturnBtn" class="btn btn-add" onclick="queueReturn()" disabled>반환대기 추가</button>
          <button id="saveReturnBtn" class="btn btn-save" onclick="saveReturnQueue()" disabled>반환대기 저장</button>
          <button id="clearReturnBtn" class="btn btn-clear" onclick="clearReturnQueue()" disabled>반환대기 비우기</button>
        </div>

        <div class="mini">
          ✅ <b>봉안번호/사망자명/신청자명</b>이 엑셀과 <b>완전 일치</b>할 때만 반환 등록 가능
        </div>
      </div>
    </div>

    <!-- 상태 -->
    <div id="statusMsg" class="status"></div>

    <!-- 대기목록 -->
    <div class="box" style="margin-bottom:12px;">
      <div class="box-title">신규 대기목록 <span class="pill" id="newCount">0건</span></div>
      <div id="newQueueWrap"></div>
      <div class="mini" id="newMini">신규 대기목록이 비어있어.</div>
    </div>

    <div class="box" style="margin-bottom:12px;" id="returnQueueBox">
      <div class="box-title">반환 대기목록 <span class="pill" id="retCount">0건</span></div>
      <div id="retQueueWrap"></div>
      <div class="mini" id="retMini">반환 대기목록이 비어있어.</div>
    </div>

    <!-- 업로드 제외 로그 -->
    <div class="box" style="margin-bottom:12px;">
      <div class="box-title">업로드 제외 로그 <span class="pill" id="logCount">0건</span></div>
      <div id="logWrap"></div>
      <div class="mini" id="logMini">제외된 항목이 없어.</div>
    </div>

    <!-- 그리드 -->
    <div id="hotContainer"></div>

    <div class="hint">
      <b>주의:</b> 파일 더블클릭(<code>file://</code>)으로 열면 CORS로 실패할 수 있어.
      GitHub Pages 또는 로컬 서버(<code>http://localhost</code>)로 열어줘.
    </div>
  </div>

  <script>
    // ===== 설정 =====
    const BRANCH = "main";
    const FILES = {
      deceased: "data/deceased_data.xlsx",
      nature: "data/nature_data.xlsx"
    };

    // ===== 상태 =====
    let hot = null;
    let currentSha = "";
    let headers = [];
    let fileKey = "deceased";
    let isBusy = false;

    // 대기목록
    let newQueue = [];     // [{inDate,no,deceased,applicant}]
    let returnQueue = [];  // [{no,deceased,applicant,returnDate}]

    // 업로드 제외 로그
    // [{rowNo, kind:'신규'|'반환', no, deceased, applicant, reason}]
    let importLog = [];

    window.onload = () => {
      const savedOwner = localStorage.getItem("gh_owner");
      const savedRepo  = localStorage.getItem("gh_repo");
      const savedToken = localStorage.getItem("gh_token");
      const savedTarget = localStorage.getItem("gh_target");

      if (savedOwner) document.getElementById("owner").value = savedOwner;
      if (savedRepo)  document.getElementById("repo").value  = savedRepo;
      if (savedToken) document.getElementById("token").value = savedToken;

      if (savedTarget === "nature") fileKey = "nature";
      selectTarget(fileKey, true);

      renderAllQueues();
      renderImportLog();
      enableBulkButton(false);
    };

    function selectTarget(target, isInit=false) {
      fileKey = target;
      localStorage.setItem("gh_target", fileKey);

      document.getElementById("btnDeceased").classList.toggle("active", fileKey === "deceased");
      document.getElementById("btnNature").classList.toggle("active", fileKey === "nature");

      document.getElementById("newTitle").textContent = (fileKey === "deceased") ? "신규 등록 (추모의집)" : "신규 등록 (자연장지)";
      document.getElementById("lblNoNew").textContent = (fileKey === "deceased") ? "봉안번호" : "자연장번호";

      document.getElementById("returnBox").style.display = (fileKey === "deceased") ? "block" : "none";
      document.getElementById("returnQueueBox").style.display = (fileKey === "deceased") ? "block" : "none";

      // 섞이면 위험: 대기/로그 초기화
      newQueue = [];
      returnQueue = [];
      importLog = [];

      clearNewInputs();
      clearReturnInputs();
      renderAllQueues();
      renderImportLog();

      // 로드 상태 초기화
      hot = null;
      headers = [];
      currentSha = "";
      document.getElementById("hotContainer").innerHTML = "";

      enableBulkButton(false);
      setBusy(false);

      if (!isInit) showStatus("대상 변경됨. '엑셀 불러오기'부터 다시 해줘.", "loading");
    }

    function showStatus(msg, type) {
      const el = document.getElementById("statusMsg");
      el.textContent = msg;
      el.className = "status " + type;
      el.style.display = "block";
      if (type === "success") setTimeout(() => (el.style.display = "none"), 2500);
    }

    function setBusy(b) {
      isBusy = b;

      document.getElementById("loadBtn").disabled = b;

      document.getElementById("queueNewBtn").disabled = b || !hot;
      document.getElementById("saveNewBtn").disabled = b || !hot || newQueue.length === 0;
      document.getElementById("clearNewBtn").disabled = b || newQueue.length === 0;

      document.getElementById("queueReturnBtn").disabled = b || !hot || fileKey !== "deceased";
      document.getElementById("saveReturnBtn").disabled = b || !hot || fileKey !== "deceased" || returnQueue.length === 0;
      document.getElementById("clearReturnBtn").disabled = b || fileKey !== "deceased" || returnQueue.length === 0;

      document.getElementById("bulkBtn").disabled = b || !hot;
      document.getElementById("clearLogBtn").disabled = b || importLog.length === 0;
    }

    function enableBulkButton(enable) {
      const b = document.getElementById("bulkBtn");
      if (b) b.disabled = !enable;
    }

    function clearNewInputs() {
      document.getElementById("f_inDate").value = "";
      document.getElementById("f_no").value = "";
      document.getElementById("f_deceased").value = "";
      document.getElementById("f_applicant").value = "";
    }
    function clearReturnInputs() {
      document.getElementById("r_no").value = "";
      document.getElementById("r_deceased").value = "";
      document.getElementById("r_applicant").value = "";
      document.getElementById("r_returnDate").value = "";
    }

    function getInputs() {
      const owner = document.getElementById("owner").value.trim();
      const repo  = document.getElementById("repo").value.trim();
      const token = document.getElementById("token").value.trim();
      const path = FILES[fileKey];
      return { owner, repo, token, path, branch: BRANCH };
    }

    function saveInputsToLocalStorage({owner, repo, token}) {
      localStorage.setItem("gh_owner", owner);
      localStorage.setItem("gh_repo", repo);
      localStorage.setItem("gh_token", token);
    }

    function buildContentsUrl(owner, repo, path, branch) {
      return `https://api.github.com/repos/${owner}/${repo}/contents/${encodeURI(path)}?ref=${encodeURIComponent(branch)}`;
    }

    // ===== 유틸 =====
    function norm(s) {
      return String(s ?? "")
        .replace(/\s+/g, "")
        .replace(/[–—]/g, "-")
        .toLowerCase();
    }
    function escapeHtml(s) {
      return String(s ?? "")
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }
    function normalizeDate(input) {
      const raw = String(input ?? "").trim();
      if (!raw) return "";
      const onlyNum = raw.replace(/[^0-9]/g, "");
      if (onlyNum.length === 8) {
        const y = onlyNum.slice(0,4), m = onlyNum.slice(4,6), d = onlyNum.slice(6,8);
        return `${y}-${m}-${d}`;
      }
      const cleaned = raw.replace(/\./g, "-").replace(/\//g, "-");
      const parts = cleaned.split("-").map(p => p.trim()).filter(Boolean);
      if (parts.length >= 3) {
        let [y,m,d] = parts;
        if (y.length === 2) y = "20" + y;
        m = String(parseInt(m,10)).padStart(2,"0");
        d = String(parseInt(d,10)).padStart(2,"0");
        if (!/^\d{4}$/.test(y) || m === "NaN" || d === "NaN") return "";
        return `${y}-${m}-${d}`;
      }
      return "";
    }
    function findHeaderIndex(hs, candidates) {
      const list = hs.map(norm);
      for (const cand of candidates) {
        const idx = list.indexOf(norm(cand));
        if (idx !== -1) return idx;
      }
      return -1;
    }
    function uint8ArrayToBase64(u8) {
      let binary = "";
      const chunkSize = 0x8000;
      for (let i = 0; i < u8.length; i += chunkSize) {
        const chunk = u8.subarray(i, i + chunkSize);
        binary += String.fromCharCode.apply(null, chunk);
      }
      return btoa(binary);
    }

    function noHeaderCandidates() {
      return (fileKey === "deceased")
        ? ["봉안번호", "봉안 번호", "봉안no", "봉안No", "번호", "관리번호"]
        : ["자연장번호", "자연장 번호", "자연장no", "자연장No", "번호", "관리번호"];
    }

    function getCellByHeader(rowObj, candidates) {
      const keys = Object.keys(rowObj || {});
      const map = new Map(keys.map(k => [norm(k), k]));
      for (const c of candidates) {
        const key = map.get(norm(c));
        if (key !== undefined) return rowObj[key];
      }
      return "";
    }

    // ===== 로드 =====
    async function loadFile() {
      const { owner, repo, token, path, branch } = getInputs();
      if (!owner || !repo || !token) {
        showStatus("Owner / Repo / Token을 입력해줘.", "error");
        return;
      }

      saveInputsToLocalStorage({owner, repo, token});
      setBusy(true);
      showStatus("GitHub에서 파일 불러오는 중...", "loading");

      try {
        const apiUrl = buildContentsUrl(owner, repo, path, branch);

        // 1) 메타(JSON)
        const metaRes = await fetch(apiUrl, {
          headers: { "Authorization": `Bearer ${token}`, "Accept": "application/vnd.github+json" }
        });
        if (!metaRes.ok) {
          const txt = await metaRes.text();
          throw new Error(`메타 조회 실패 (${metaRes.status})\n${txt}`);
        }
        const meta = await metaRes.json();
        if (Array.isArray(meta)) throw new Error("경로가 파일이 아니라 폴더로 인식됐어.");
        currentSha = meta.sha || "";

        // 2) download_url로 다운로드(헤더 없이)
        if (!meta.download_url) throw new Error("download_url이 없어. 파일 공개/경로 확인 필요.");
        const fileRes = await fetch(meta.download_url);
        if (!fileRes.ok) {
          const txt = await fileRes.text();
          throw new Error(`download_url 다운로드 실패 (${fileRes.status})\n${txt}`);
        }

        const buf = await fileRes.arrayBuffer();
        const bytes = new Uint8Array(buf);

        // 3) 파싱
        const wb = XLSX.read(bytes, { type: "array" });
        const ws = wb.Sheets[wb.SheetNames[0]];
        const aoa = XLSX.utils.sheet_to_json(ws, { header: 1, defval: "" });

        initGrid(aoa);

        enableBulkButton(true);
        showStatus("로드 완료! (업로드/신규/반환) 대기목록을 채워서 저장해.", "success");
      } catch (e) {
        enableBulkButton(false);
        showStatus(e.message || String(e), "error");
      } finally {
        setBusy(false);
      }
    }

    function initGrid(aoa) {
      const container = document.getElementById("hotContainer");
      container.innerHTML = "";

      headers = (aoa && aoa.length > 0) ? aoa[0].map(h => String(h ?? "").trim()) : [];
      const bodyData = (aoa && aoa.length > 1) ? aoa.slice(1) : [];

      // 추모의집: 반환일자 컬럼 없으면 생성
      if (fileKey === "deceased") {
        const idxReturn = findHeaderIndex(headers, ["반환일자", "반환 일자", "반환일"]);
        if (idxReturn === -1) headers.push("반환일자");
        for (const row of bodyData) while (row.length < headers.length) row.push("");
      }

      hot = new Handsontable(container, {
        data: bodyData,
        rowHeaders: true,
        colHeaders: headers,
        height: 560,
        width: "100%",
        stretchH: "all",
        licenseKey: "non-commercial-and-evaluation",
        readOnly: true,
        contextMenu: false,
        manualColumnResize: true,
        manualRowResize: true,
        filters: true,
        dropdownMenu: true
      });

      setTimeout(() => { hot.render(); hot.refreshDimensions(); }, 0);
      setBusy(false);
    }

    // ===== 중복(신규) =====
    function isDuplicateNoInExcel(noVal) {
      const v = norm(noVal);
      if (!v) return false;
      const idxNo = findHeaderIndex(headers, noHeaderCandidates());
      if (idxNo === -1) throw new Error((fileKey === "deceased" ? "봉안번호" : "자연장번호") + " 헤더를 못 찾았어.");
      const rows = hot.getData();
      for (const row of rows) {
        if (norm(row[idxNo]) === v) return true;
      }
      return false;
    }
    function isDuplicateNoInNewQueue(noVal) {
      const v = norm(noVal);
      for (const q of newQueue) if (norm(q.no) === v) return true;
      return false;
    }

    // ===== 반환: 기존행 완전일치 찾기 =====
    function findExactMatchRow(noVal, deceasedVal, applicantVal) {
      const idxNo = findHeaderIndex(headers, ["봉안번호", "봉안 번호", "봉안no", "봉안No", "번호", "관리번호"]);
      const idxDe = findHeaderIndex(headers, ["사망자명", "고인명", "고인", "사망자"]);
      const idxAp = findHeaderIndex(headers, ["신청자명", "신청자", "사용자명", "계약자명"]);
      const idxReturn = findHeaderIndex(headers, ["반환일자", "반환 일자", "반환일"]);

      const missing = [];
      if (idxNo === -1) missing.push("봉안번호");
      if (idxDe === -1) missing.push("사망자명");
      if (idxAp === -1) missing.push("신청자명");
      if (idxReturn === -1) missing.push("반환일자");
      if (missing.length) throw new Error("봉안 엑셀 헤더를 못 찾았어: " + missing.join(", "));

      const rows = hot.getData();
      const noN = norm(noVal), deN = norm(deceasedVal), apN = norm(applicantVal);

      for (let r = 0; r < rows.length; r++) {
        const row = rows[r];
        if (norm(row[idxNo]) === noN && norm(row[idxDe]) === deN && norm(row[idxAp]) === apN) {
          const hasReturn = String(row[idxReturn] ?? "").trim() !== "";
          return { found: true, rowIndex: r, idxReturn, hasReturn };
        }
      }
      return { found: false };
    }

    // ===== 신규 대기 추가 =====
    function queueNew() {
      if (!hot) { showStatus("먼저 엑셀 불러오기를 해줘.", "error"); return; }

      try {
        const inDateRaw = document.getElementById("f_inDate").value.trim();
        const noRaw = document.getElementById("f_no").value.trim();
        const deceased = document.getElementById("f_deceased").value.trim();
        const applicant = document.getElementById("f_applicant").value.trim();

        if (!inDateRaw || !noRaw || !deceased || !applicant) {
          showStatus("필수 항목(안치일자/번호/사망자명/신청자명)을 다 입력해줘.", "error");
          return;
        }

        const inDate = normalizeDate(inDateRaw);
        if (!inDate) { showStatus("안치일자 형식이 이상해.", "error"); return; }

        if (isDuplicateNoInExcel(noRaw)) {
          showStatus((fileKey === "deceased" ? "봉안번호" : "자연장번호") + "가 엑셀에 이미 있어(중복).", "error");
          return;
        }
        if (isDuplicateNoInNewQueue(noRaw)) {
          showStatus((fileKey === "deceased" ? "봉안번호" : "자연장번호") + "가 신규대기에 이미 있어(중복).", "error");
          return;
        }

        newQueue.push({ inDate, no: noRaw, deceased, applicant });
        renderAllQueues();
        clearNewInputs();
        showStatus("신규 대기목록에 추가했어.", "success");
      } catch (e) {
        showStatus(e.message || String(e), "error");
      }
    }

    function clearNewQueue() {
      newQueue = [];
      renderAllQueues();
      showStatus("신규 대기목록을 비웠어.", "success");
    }

    // ===== 반환 대기 추가 =====
    function queueReturn() {
      if (!hot) { showStatus("먼저 엑셀 불러오기를 해줘.", "error"); return; }
      if (fileKey !== "deceased") { showStatus("반환 등록은 추모의집에서만 가능해.", "error"); return; }

      try {
        const noRaw = document.getElementById("r_no").value.trim();
        const deceased = document.getElementById("r_deceased").value.trim();
        const applicant = document.getElementById("r_applicant").value.trim();
        const returnRaw = document.getElementById("r_returnDate").value.trim();

        if (!noRaw || !deceased || !applicant || !returnRaw) {
          showStatus("필수 항목(봉안번호/사망자명/신청자명/반환일자)을 다 입력해줘.", "error");
          return;
        }

        const returnDate = normalizeDate(returnRaw);
        if (!returnDate) { showStatus("반환일자 형식이 이상해.", "error"); return; }

        const match = findExactMatchRow(noRaw, deceased, applicant);
        if (!match.found) {
          showStatus("일치하는 기존 봉안정보를 못 찾았어.\n(봉안번호/사망자명/신청자명이 엑셀과 완전 일치해야 함)", "error");
          return;
        }
        if (match.hasReturn) {
          showStatus("이미 반환일자가 등록된 건이야.", "error");
          return;
        }

        const key = norm(noRaw) + "|" + norm(deceased) + "|" + norm(applicant);
        for (const q of returnQueue) {
          const k2 = norm(q.no) + "|" + norm(q.deceased) + "|" + norm(q.applicant);
          if (k2 === key) { showStatus("반환대기에 이미 같은 건이 있어.", "error"); return; }
        }

        returnQueue.push({ no: noRaw, deceased, applicant, returnDate });
        renderAllQueues();
        clearReturnInputs();
        showStatus("반환 대기목록에 추가했어.", "success");
      } catch (e) {
        showStatus(e.message || String(e), "error");
      }
    }

    function clearReturnQueue() {
      returnQueue = [];
      renderAllQueues();
      showStatus("반환 대기목록을 비웠어.", "success");
    }

    // ===== 업로드 제외 로그 =====
    function addImportLog(item) {
      importLog.push(item);
    }
    function clearImportLog() {
      importLog = [];
      renderImportLog();
      showStatus("업로드 로그를 비웠어.", "success");
      setBusy(isBusy);
    }

    function renderImportLog() {
      document.getElementById("logCount").textContent = `${importLog.length}건`;
      const wrap = document.getElementById("logWrap");
      const mini = document.getElementById("logMini");
      document.getElementById("clearLogBtn").disabled = isBusy || importLog.length === 0;

      if (importLog.length === 0) {
        wrap.innerHTML = "";
        mini.textContent = "제외된 항목이 없어.";
        return;
      }

      mini.textContent = "업로드에서 제외된 항목과 이유야.";
      let html = `<table class="q"><thead><tr>
        <th style="width:90px;">엑셀행</th>
        <th style="width:80px;">구분</th>
        <th>번호</th>
        <th>사망자명</th>
        <th>신청자명</th>
        <th>제외 사유</th>
      </tr></thead><tbody>`;

      importLog.forEach(l => {
        html += `<tr>
          <td>${escapeHtml(l.rowNo)}</td>
          <td><span class="pill">${escapeHtml(l.kind)}</span></td>
          <td><b>${escapeHtml(l.no || "")}</b></td>
          <td>${escapeHtml(l.deceased || "")}</td>
          <td>${escapeHtml(l.applicant || "")}</td>
          <td class="danger">${escapeHtml(l.reason)}</td>
        </tr>`;
      });

      html += `</tbody></table>`;
      wrap.innerHTML = html;
    }

    // ===== 업로드 → 대기목록 반영 (반환일자 있으면 반환, 없으면 신규) =====
    async function importBulkExcel() {
      if (!hot) {
        showStatus("먼저 GitHub 엑셀 불러오기를 해줘.", "error");
        return;
      }
      if (isBusy) return;

      const input = document.getElementById("bulkFile");
      if (!input || !input.files || input.files.length === 0) {
        showStatus("업로드할 엑셀 파일을 선택해줘.", "error");
        return;
      }

      const file = input.files[0];

      setBusy(true);
      showStatus("업로드 엑셀 읽는 중...", "loading");

      try {
        const buf = await file.arrayBuffer();
        const wb = XLSX.read(new Uint8Array(buf), { type: "array" });

        const ws = wb.Sheets[wb.SheetNames[0]];
        const rows = XLSX.utils.sheet_to_json(ws, { defval: "" }); // 1행=헤더

        if (!rows || rows.length === 0) throw new Error("업로드 엑셀에 데이터가 없어.");

        // 업로드 한 번 돌릴 때 로그는 누적(원하면 초기화해도 됨)
        let addedNew = 0, addedRet = 0, skipped = 0;

        for (let i = 0; i < rows.length; i++) {
          const r = rows[i];
          const rowNo = i + 2; // sheet_to_json은 1행=헤더 가정 -> 데이터 첫 줄이 엑셀 2행

          const noRaw = String(getCellByHeader(r, ["봉안번호","봉안 번호","자연장번호","자연장 번호","번호","관리번호"])).trim();
          const deceased = String(getCellByHeader(r, ["사망자명","고인명","고인","사망자"])).trim();
          const applicant = String(getCellByHeader(r, ["신청자명","신청자","사용자명","계약자명"])).trim();

          const inDateRaw = String(getCellByHeader(r, ["안치일자","안치 일자","안치일"])).trim();
          const returnRaw = String(getCellByHeader(r, ["반환일자","반환 일자","반환일"])).trim();

          const isReturn = !!String(returnRaw).trim();
          const kind = isReturn ? "반환" : "신규";

          // 공통 필수
          if (!noRaw || !deceased || !applicant) {
            skipped++;
            addImportLog({ rowNo, kind, no: noRaw, deceased, applicant, reason: "필수값 누락(번호/사망자명/신청자명)" });
            continue;
          }

          if (isReturn) {
            // 반환은 추모의집에서만
            if (fileKey !== "deceased") {
              skipped++;
              addImportLog({ rowNo, kind, no: noRaw, deceased, applicant, reason: "자연장지 대상에서는 반환 처리 불가" });
              continue;
            }

            const returnDate = normalizeDate(returnRaw);
            if (!returnDate) {
              skipped++;
              addImportLog({ rowNo, kind, no: noRaw, deceased, applicant, reason: "반환일자 형식 오류" });
              continue;
            }

            let match;
            try {
              match = findExactMatchRow(noRaw, deceased, applicant);
            } catch (e) {
              skipped++;
              addImportLog({ rowNo, kind, no: noRaw, deceased, applicant, reason: e.message || "헤더 확인 필요" });
              continue;
            }

            if (!match.found) {
              skipped++;
              addImportLog({ rowNo, kind, no: noRaw, deceased, applicant, reason: "기존정보 불일치(완전일치 행 없음)" });
              continue;
            }
            if (match.hasReturn) {
              skipped++;
              addImportLog({ rowNo, kind, no: noRaw, deceased, applicant, reason: "이미 반환일자 등록됨" });
              continue;
            }

            const key = norm(noRaw) + "|" + norm(deceased) + "|" + norm(applicant);
            let dup = false;
            for (const q of returnQueue) {
              const k2 = norm(q.no) + "|" + norm(q.deceased) + "|" + norm(q.applicant);
              if (k2 === key) { dup = true; break; }
            }
            if (dup) {
              skipped++;
              addImportLog({ rowNo, kind, no: noRaw, deceased, applicant, reason: "반환대기 중복(같은 3키)" });
              continue;
            }

            returnQueue.push({ no: noRaw, deceased, applicant, returnDate });
            addedRet++;
            continue;
          }

          // 신규
          if (!inDateRaw) {
            skipped++;
            addImportLog({ rowNo, kind, no: noRaw, deceased, applicant, reason: "안치일자 누락(신규)" });
            continue;
          }
          const inDate = normalizeDate(inDateRaw);
          if (!inDate) {
            skipped++;
            addImportLog({ rowNo, kind, no: noRaw, deceased, applicant, reason: "안치일자 형식 오류(신규)" });
            continue;
          }

          try {
            if (isDuplicateNoInExcel(noRaw)) {
              skipped++;
              addImportLog({ rowNo, kind, no: noRaw, deceased, applicant, reason: "중복(엑셀 기존 번호)" });
              continue;
            }
            if (isDuplicateNoInNewQueue(noRaw)) {
              skipped++;
              addImportLog({ rowNo, kind, no: noRaw, deceased, applicant, reason: "중복(신규대기 번호)" });
              continue;
            }
          } catch (e) {
            skipped++;
            addImportLog({ rowNo, kind, no: noRaw, deceased, applicant, reason: e.message || "중복 체크 실패" });
            continue;
          }

          newQueue.push({ inDate, no: noRaw, deceased, applicant });
          addedNew++;
        }

        renderAllQueues();
        renderImportLog();
        showStatus(`업로드 반영 완료!\n신규 ${addedNew}건 / 반환 ${addedRet}건 / 제외 ${skipped}건`, "success");
      } catch (e) {
        showStatus(e.message || String(e), "error");
      } finally {
        setBusy(false);
      }
    }

    // ===== 대기목록 렌더 =====
    function renderAllQueues() {
      // 신규
      document.getElementById("newCount").textContent = `${newQueue.length}건`;
      const newWrap = document.getElementById("newQueueWrap");
      const newMini = document.getElementById("newMini");

      if (newQueue.length === 0) {
        newWrap.innerHTML = "";
        newMini.textContent = "신규 대기목록이 비어있어.";
      } else {
        newMini.textContent = "신규 대기목록 확인 후 저장해.";
        const noLabel = (fileKey === "deceased") ? "봉안번호" : "자연장번호";
        let html = `<table class="q"><thead><tr>
          <th style="width:60px;">삭제</th>
          <th>안치일자</th>
          <th>${noLabel}</th>
          <th>사망자명</th>
          <th>신청자명</th>
        </tr></thead><tbody>`;
        newQueue.forEach((q, idx) => {
          html += `<tr>
            <td><button class="btn btn-clear" style="padding:6px 10px; font-size:12px;" onclick="removeNew(${idx})">삭제</button></td>
            <td>${escapeHtml(q.inDate)}</td>
            <td><b>${escapeHtml(q.no)}</b></td>
            <td>${escapeHtml(q.deceased)}</td>
            <td>${escapeHtml(q.applicant)}</td>
          </tr>`;
        });
        html += `</tbody></table>`;
        newWrap.innerHTML = html;
      }

      // 반환(추모의집만)
      if (fileKey === "deceased") {
        document.getElementById("retCount").textContent = `${returnQueue.length}건`;
        const retWrap = document.getElementById("retQueueWrap");
        const retMini = document.getElementById("retMini");
        if (returnQueue.length === 0) {
          retWrap.innerHTML = "";
          retMini.textContent = "반환 대기목록이 비어있어.";
        } else {
          retMini.textContent = "반환 대기목록 확인 후 저장해.";
          let html = `<table class="q"><thead><tr>
            <th style="width:60px;">삭제</th>
            <th>봉안번호</th>
            <th>사망자명</th>
            <th>신청자명</th>
            <th>반환일자</th>
          </tr></thead><tbody>`;
          returnQueue.forEach((q, idx) => {
            html += `<tr>
              <td><button class="btn btn-clear" style="padding:6px 10px; font-size:12px;" onclick="removeReturn(${idx})">삭제</button></td>
              <td><b>${escapeHtml(q.no)}</b></td>
              <td>${escapeHtml(q.deceased)}</td>
              <td>${escapeHtml(q.applicant)}</td>
              <td>${escapeHtml(q.returnDate)}</td>
            </tr>`;
          });
          html += `</tbody></table>`;
          retWrap.innerHTML = html;
        }
      }

      // 버튼 상태 반영
      setBusy(isBusy);
    }

    function removeNew(idx) { newQueue.splice(idx, 1); renderAllQueues(); }
    function removeReturn(idx) { returnQueue.splice(idx, 1); renderAllQueues(); }

    // ===== 저장 공통 =====
    async function putToGitHub(mergedAoa, message) {
      const { owner, repo, token, path, branch } = getInputs();
      const apiUrl = buildContentsUrl(owner, repo, path, branch);

      const ws = XLSX.utils.aoa_to_sheet(mergedAoa);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, "Sheet1");

      const wbOut = XLSX.write(wb, { bookType: "xlsx", type: "array" });
      const bytes = new Uint8Array(wbOut);
      const contentBase64 = uint8ArrayToBase64(bytes);

      const putBody = { message, content: contentBase64, sha: currentSha, branch };

      const res = await fetch(apiUrl, {
        method: "PUT",
        headers: {
          "Authorization": `Bearer ${token}`,
          "Accept": "application/vnd.github+json",
          "Content-Type": "application/json"
        },
        body: JSON.stringify(putBody)
      });

      if (!res.ok) {
        const txt = await res.text();
        throw new Error(`저장 실패 (${res.status})\n${txt}`);
      }

      const resData = await res.json();
      currentSha = resData.content?.sha || currentSha;
    }

    // ===== 신규대기 저장 =====
    async function saveNewQueue() {
      if (!hot) { showStatus("먼저 엑셀 불러오기를 해줘.", "error"); return; }
      if (newQueue.length === 0) { showStatus("신규 대기목록이 비어있어.", "error"); return; }

      const { owner, repo, token } = getInputs();
      if (!owner || !repo || !token) { showStatus("Owner / Repo / Token이 누락됐어.", "error"); return; }

      setBusy(true);
      showStatus("신규 대기목록을 엑셀에 반영하고 저장 중...", "loading");

      try {
        const idxInDate = findHeaderIndex(headers, ["안치일자", "안치 일자", "안치일"]);
        const idxNo = findHeaderIndex(headers, noHeaderCandidates());
        const idxDe = findHeaderIndex(headers, ["사망자명", "고인명", "고인", "사망자"]);
        const idxAp = findHeaderIndex(headers, ["신청자명", "신청자", "사용자명", "계약자명"]);

        const missing = [];
        if (idxInDate === -1) missing.push("안치일자");
        if (idxNo === -1) missing.push(fileKey === "deceased" ? "봉안번호" : "자연장번호");
        if (idxDe === -1) missing.push("사망자명");
        if (idxAp === -1) missing.push("신청자명");
        if (missing.length) throw new Error("엑셀 헤더를 못 찾았어: " + missing.join(", "));

        const dataRows = hot.getData();

        // 저장 직전 중복검사: 엑셀 기존 + 신규대기 내부
        const existingSet = new Set();
        for (const row of dataRows) {
          const v = norm(row[idxNo]);
          if (v) existingSet.add(v);
        }
        const batchSet = new Set();

        for (const q of newQueue) {
          const vv = norm(q.no);
          if (existingSet.has(vv)) throw new Error(`중복(엑셀 기존): ${q.no}`);
          if (batchSet.has(vv)) throw new Error(`중복(신규대기 내부): ${q.no}`);
          batchSet.add(vv);
          existingSet.add(vv);

          const row = new Array(headers.length).fill("");
          row[idxInDate] = q.inDate;
          row[idxNo] = q.no;
          row[idxDe] = q.deceased;
          row[idxAp] = q.applicant;
          dataRows.push(row);
        }

        const merged = [headers, ...dataRows];
        await putToGitHub(merged, `Append ${newQueue.length} new rows: ${new Date().toISOString()}`);

        hot.loadData(dataRows);
        setTimeout(() => { hot.render(); hot.refreshDimensions(); }, 0);

        newQueue = [];
        renderAllQueues();
        showStatus("신규 저장 완료!", "success");
      } catch (e) {
        showStatus(e.message || String(e), "error");
      } finally {
        setBusy(false);
      }
    }

    // ===== 반환대기 저장 =====
    async function saveReturnQueue() {
      if (!hot) { showStatus("먼저 엑셀 불러오기를 해줘.", "error"); return; }
      if (fileKey !== "deceased") { showStatus("반환 저장은 추모의집에서만 가능해.", "error"); return; }
      if (returnQueue.length === 0) { showStatus("반환 대기목록이 비어있어.", "error"); return; }

      const { owner, repo, token } = getInputs();
      if (!owner || !repo || !token) { showStatus("Owner / Repo / Token이 누락됐어.", "error"); return; }

      setBusy(true);
      showStatus("반환 대기목록을 엑셀에 반영하고 저장 중...", "loading");

      try {
        const idxReturn = findHeaderIndex(headers, ["반환일자", "반환 일자", "반환일"]);
        if (idxReturn === -1) throw new Error("반환일자 컬럼을 못 찾았어.");

        const rows = hot.getData();

        // 반환대기 내부 중복키(3키)
        const batchKey = new Set();
        for (const q of returnQueue) {
          const k = norm(q.no) + "|" + norm(q.deceased) + "|" + norm(q.applicant);
          if (batchKey.has(k)) throw new Error(`반환대기 내부 중복: ${q.no}`);
          batchKey.add(k);
        }

        // 적용
        for (const q of returnQueue) {
          const match = findExactMatchRow(q.no, q.deceased, q.applicant);
          if (!match.found) throw new Error(`일치 정보 없음: ${q.no} / ${q.deceased} / ${q.applicant}`);
          if (match.hasReturn) throw new Error(`이미 반환 등록됨: ${q.no} / ${q.deceased} / ${q.applicant}`);
          rows[match.rowIndex][match.idxReturn] = q.returnDate;
        }

        const merged = [headers, ...rows];
        await putToGitHub(merged, `Register ${returnQueue.length} returns: ${new Date().toISOString()}`);

        hot.loadData(rows);
        setTimeout(() => { hot.render(); hot.refreshDimensions(); }, 0);

        returnQueue = [];
        renderAllQueues();
        showStatus("반환 저장 완료!", "success");
      } catch (e) {
        showStatus(e.message || String(e), "error");
      } finally {
        setBusy(false);
      }
    }
  </script>
</body>
</html>
