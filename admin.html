<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>울산하늘공원 데이터 관리자</title>

  <link rel="icon" type="image/x-icon" href="./images/symbol.png">
  <link rel="apple-touch-icon" href="./images/symbol.png">

  <!-- Handsontable -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/handsontable/dist/handsontable.full.min.css" />
  <script src="https://cdn.jsdelivr.net/npm/handsontable/dist/handsontable.full.min.js"></script>

  <!-- XLSX -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <style>
    :root{
      --bg:#f6f7f9;
      --panel:#ffffff;
      --text:#111827;
      --muted:#6b7280;

      --line:#d1d5db;
      --line-soft:#e5e7eb;

      --primary:#2f6fb2;
      --primary-h:#285f98;

      --success:#0f766e;
      --warn:#b45309;
      --danger:#b42318;

      --shadow: 0 6px 14px rgba(17, 24, 39, 0.08);
      --radius:6px;
      --radius-sm:4px;

      --header:#eef2f7;
    }

    *{ box-sizing:border-box; }
    body{
      margin:0;
      padding:18px;
      background: var(--bg);
      color:var(--text);
      font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue",
        Arial, "Apple SD Gothic Neo", "Noto Sans KR", sans-serif;
      display:flex;
      justify-content:center;
      font-size:15px;
    }

    .container{
      width:100%;
      max-width:1320px;
      background:var(--panel);
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }

    .header{
      padding:14px 16px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      border-bottom:1px solid var(--line);
      background: var(--header);
    }
    .header-left{
      display:flex;
      flex-direction:column;
      gap:8px;
      min-width:0;
    }
    .title{
      font-size:20px;
      font-weight:900;
      letter-spacing:-0.2px;
      margin:0;
      line-height:1.15;
    }

    .meta-line{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      min-height:24px;
      color:var(--muted);
      font-size:13px;
      font-weight:700;
    }
    .meta-item{
      display:inline-flex;
      gap:6px;
      align-items:center;
      padding:3px 8px;
      border:1px solid var(--line-soft);
      background:#fff;
      border-radius: var(--radius-sm);
      color:#374151;
      white-space:nowrap;
    }
    .meta-item b{ font-weight:900; }
    .hidden{ display:none !important; }

    .header-right{
      display:flex;
      align-items:center;
      gap:12px;
      flex-shrink:0;
    }
    .logo{
      height:38px;
      width:auto;
      display:block;
      filter: saturate(0.95) contrast(0.98);
    }

    .content{ padding:14px 16px 16px; }

    /* ✅ 상단 2개 박스(깃허브 설정/일괄등록) 가로 배치 */
    .top-panels{
      display:grid;
      grid-template-columns: 1.25fr 0.75fr;
      gap:12px;
      align-items:start;
      margin-bottom:12px;
    }
    .top-panels .box{ margin-bottom:0; }
    @media (max-width: 980px){
      .top-panels{ grid-template-columns: 1fr; }
    }

    .box{
      background:#fff;
      border:1px solid var(--line);
      border-radius: var(--radius);
      padding:14px;
      margin-bottom:12px;
    }

    .box-title{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      font-weight:900;
      margin-bottom:10px;
      color:#111827;
      font-size:15px;
    }
    .hint-mini{
      font-size:13px;
      font-weight:700;
      color:var(--muted);
    }

    .row{
      display:grid;
      grid-template-columns:repeat(auto-fit, minmax(240px, 1fr));
      gap:10px;
      margin:0;
    }

    .form-group label{
      display:block;
      font-weight:800;
      font-size:13px;
      margin-bottom:6px;
      color:#374151;
    }
    .form-group input{
      width:100%;
      padding:10px 10px;
      border:1px solid var(--line);
      border-radius: var(--radius-sm);
      background:#fff;
      font-size:14px;
      outline:none;
      transition:0.12s;
    }
    .form-group input:focus{
      border-color:#9bb9dd;
      box-shadow:0 0 0 3px rgba(47,111,178,0.14);
    }

    .input-with-btn{ display:flex; gap:8px; align-items:center; }

    .field-help{
      margin-top:6px;
      font-size:12px;
      color:var(--muted);
      font-weight:700;
      line-height:1.35;
    }
    .field-help .pill{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:2px 8px;
      border-radius:999px;
      border:1px solid var(--line-soft);
      background:#fff;
      color:#374151;
      font-weight:900;
      margin-right:6px;
      white-space:nowrap;
    }

    .toolbar{
      margin-top:10px;
      display:flex;
      align-items:center;
      justify-content:flex-end;
      gap:8px;
      flex-wrap:wrap;
    }

    .btn{
      border:1px solid var(--line);
      padding:9px 12px;
      border-radius: var(--radius-sm);
      font-size:14px;
      font-weight:800;
      cursor:pointer;
      transition:0.12s;
      display:inline-flex;
      align-items:center;
      gap:8px;
      background:#fff;
      color:#111827;
      min-height:36px;
    }
    .btn:disabled{ opacity:0.55; cursor:not-allowed; }
    .btn:hover{ background:#f9fafb; }
    .btn:focus-visible{ outline:none; box-shadow:0 0 0 3px rgba(47,111,178,0.14); }

    .btn-primary{
      background: var(--primary);
      border-color: var(--primary);
      color:#fff;
    }
    .btn-primary:hover{ background: var(--primary-h); border-color: var(--primary-h); }

    .btn-ghost{ background:#fff; border-color: var(--line); color:#111827; }

    .icon-btn{
      border:1px solid var(--line);
      background:#fff;
      color:#111827;
      padding:9px 10px;
      border-radius: var(--radius-sm);
      font-weight:800;
      cursor:pointer;
      transition:0.12s;
      white-space:nowrap;
      min-height:36px;
    }
    .icon-btn:hover{ background:#f9fafb; }

    .load-hint{
      display:none;
      font-size:13px;
      font-weight:800;
      color:#374151;
      padding:8px 10px;
      border:1px dashed #cbd5e1;
      background:#f8fafc;
      border-radius: var(--radius-sm);
      white-space:nowrap;
    }

    .status{
      display:none;
      position: sticky;
      top: 10px;
      z-index: 50;
      margin:10px 0 12px;
      padding:10px 12px;
      border-radius: var(--radius-sm);
      border:1px solid var(--line);
      background:#fff;
      color:#111827;
      white-space:pre-wrap;
      font-size:14px;
      cursor:pointer;
    }
    .status.success{ border-color:#99f6e4; background:#f0fdfa; color:#134e4a; }
    .status.error{ border-color:#fecdd3; background:#fff1f2; color:#7f1d1d; }
    .status.loading{ background:#f8fafc; color:#374151; }

    .file-panel{
      border:1px solid var(--line-soft);
      background:#fafafa;
      border-radius: var(--radius-sm);
      padding:10px;
      transition:0.12s;
    }
    /* ✅ 드래그 앤 드롭 UX */
    .file-panel.drop-ready{
      outline: 2px dashed rgba(47,111,178,0.35);
      outline-offset: 2px;
      background: #f3f7ff;
    }

    .file-panel-head{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:8px;
    }
    .file-panel-title{
      font-size:13px;
      font-weight:900;
      color:#111827;
      display:flex;
      align-items:center;
      gap:8px;
      white-space:nowrap;
    }
    .count{
      font-weight:900;
      color:#111827;
      background:#fff;
      border:1px solid var(--line-soft);
      padding:2px 8px;
      border-radius: var(--radius-sm);
      white-space:nowrap;
      font-size:12px;
    }
    .file-panel-actions{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
    }

    .file-list{
      list-style:none;
      padding:0;
      margin:0;
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .file-list li{
      display:grid;
      grid-template-columns: 1fr auto;
      align-items:center;
      gap:10px;
      padding:7px 8px;
      background:#fff;
      border:1px solid var(--line-soft);
      border-radius: var(--radius-sm);
      font-size:13px;
      color:#111827;
    }
    .file-left{
      display:flex;
      flex-direction:column;
      gap:2px;
      min-width:0;
    }
    .file-name{
      font-weight:900;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .file-sub{
      font-size:12px;
      color:var(--muted);
      font-weight:800;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
    }
    .mono{
      font-variant-numeric: tabular-nums;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    .x-btn{
      border:1px solid var(--line);
      background:#fff;
      color:#374151;
      width:28px;
      height:28px;
      border-radius: var(--radius-sm);
      cursor:pointer;
      font-weight:900;
      line-height:1;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      flex-shrink:0;
    }
    .x-btn:hover{ background:#f9fafb; }

    .muted{ color:var(--muted); font-weight:800; }

    .grid-head{
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      gap:12px;
      margin-bottom:10px;
      border-bottom:1px solid var(--line);
      padding-bottom:8px;
    }
    .tabs{
      display:inline-flex;
      gap:0;
      border:1px solid var(--line);
      border-bottom:0;
      background:#fff;
    }
    .tab-btn{
      border:0;
      background:#f9fafb;
      cursor:pointer;
      padding:9px 14px;
      font-weight:900;
      font-size:13px;
      color:#374151;
      border-right:1px solid var(--line);
      border-radius:0;
      min-width:110px;
    }
    .tab-btn:last-child{ border-right:0; }
    .tab-btn:disabled{ opacity:0.55; cursor:not-allowed; }
    .tab-btn.active{
      background:#fff;
      color:#111827;
      border-bottom:2px solid #fff;
    }
    .grid-meta{
      font-size:12px;
      color:#374151;
      font-weight:900;
      white-space:nowrap;
      padding-bottom:2px;
    }

    #hotContainer{
      width:100%;
      height:560px;
      border:1px solid var(--line);
      border-radius: var(--radius);
      overflow:hidden;
      background:#fff;
    }
    .hot-row-highlight{ background: rgba(47,111,178,0.12) !important; }

    .modal-backdrop{
      position:fixed;
      inset:0;
      background: rgba(17, 24, 39, 0.45);
      display:none;
      align-items:center;
      justify-content:center;
      padding:16px;
      z-index:9999;
    }
    .modal{
      width:100%;
      max-width:1200px;
      background:#fff;
      border-radius: var(--radius);
      border:1px solid var(--line);
      box-shadow: 0 18px 60px rgba(17, 24, 39, 0.35);
      overflow:hidden;
    }
    .modal-head{
      padding:12px 14px;
      border-bottom:1px solid var(--line);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      background:#f8fafc;
    }
    .modal-title{
      font-size:14px;
      font-weight:900;
      margin:0;
      color:#111827;
    }
    .modal-body{
      padding:12px 14px;
      color:#111827;
      font-size:13px;
      line-height:1.5;
      max-height:72vh;
      overflow:auto;
    }
    .modal-foot{
      padding:12px 14px;
      border-top:1px solid var(--line);
      display:flex;
      justify-content:flex-end;
      gap:8px;
      background:#fafafa;
    }

    .file-section{
      margin-top:12px;
      border:1px solid var(--line);
      border-radius: var(--radius-sm);
      overflow:hidden;
      background:#fff;
    }
    .file-section-head{
      padding:10px 12px;
      background:#f3f4f6;
      border-bottom:1px solid var(--line-soft);
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      font-weight:900;
      color:#111827;
      font-size:13px;
    }
    .file-section-head .mini{
      font-size:12px;
      color:#374151;
      font-weight:900;
      background:#fff;
      border:1px solid var(--line-soft);
      padding:2px 8px;
      border-radius: var(--radius-sm);
      white-space:nowrap;
    }

    table.q{
      width:100%;
      border-collapse:collapse;
      border:0;
      background:#fff;
      font-size:13px;
    }
    table.q th, table.q td{
      border-bottom:1px solid var(--line-soft);
      border-right:1px solid var(--line-soft);
      padding:8px 10px;
      text-align:left;
      vertical-align:top;
    }
    table.q th{
      background:#fafafa;
      font-weight:900;
      color:#374151;
    }
    table.q tr:last-child td{ border-bottom:0; }
    table.q th:last-child, table.q td:last-child{ border-right:0; }
    .danger{ color:var(--danger); font-weight:900; white-space:pre-wrap; }
  </style>
</head>

<body>
  <div class="container">
    <div class="header">
      <div class="header-left">
        <h1 class="title">울산하늘공원 데이터 관리자</h1>
        <div class="meta-line">
          <span id="badgeOwner" class="meta-item hidden">Owner: <b>-</b></span>
          <span id="badgeRepo"  class="meta-item hidden">Repo: <b>-</b></span>
          <span id="badgeBranch" class="meta-item hidden">Branch: <b>-</b></span>
          <span id="badgeLoadedAt" class="meta-item hidden">마지막 로드: <b>-</b></span>
          <span id="badgeLoadedFiles" class="meta-item hidden">로드: <b>-</b></span>
        </div>
      </div>
      <div class="header-right">
        <img class="logo" src="./images/ulsan_logo1.png" alt="울산 로고" />
      </div>
    </div>

    <div class="content">

      <!-- ✅ 상단 2단 배치 -->
      <div class="top-panels">

        <!-- GitHub 설정 -->
        <div class="box">
          <div class="box-title">
            <span>GitHub 설정</span>
            <span class="hint-mini">추모의집/자연장지 데이터를 불러온 후 등록 반영을 진행합니다</span>
          </div>

          <div class="row">
            <div class="form-group">
              <label>GitHub Owner</label>
              <input type="text" id="owner" placeholder="예: UL-SkyPark" autocomplete="off" />
            </div>
            <div class="form-group">
              <label>Repository</label>
              <input type="text" id="repo" placeholder="예: ulsan-skypark-search" autocomplete="off" />
            </div>
            <div class="form-group">
              <label>Branch</label>
              <input type="text" id="branch" placeholder="예: main" autocomplete="off" />
              <div class="field-help">
                <span class="pill">안내</span>기본값은 <b>main</b>입니다. 운영 브랜치가 다르면 여기에서 변경해 주세요.
              </div>
            </div>

            <div class="form-group" style="grid-column: 1 / -1;">
              <label>Access Token</label>
              <div class="input-with-btn">
                <input type="password" id="token" placeholder="ghp_... 또는 fine-grained token" autocomplete="off" />
                <button type="button" class="icon-btn" id="tokenToggleBtn" onclick="toggleToken()">보기</button>
                <button type="button" class="icon-btn" id="clearTokenBtn" onclick="clearSavedToken()" title="브라우저에 저장된 토큰만 삭제합니다">
                  저장토큰 삭제
                </button>
              </div>
              <div class="field-help">
                <span class="pill">권한</span>fine-grained token이면 <b>Contents</b> 권한(읽기/쓰기)을 확인해 주세요.<br>
                <span class="pill">보안</span>토큰은 이 브라우저(localStorage)에 저장됩니다. 공용 PC에서는 저장토큰 삭제를 눌러 주세요.
              </div>
            </div>
          </div>

          <div class="toolbar">
            <div id="loadHint" class="load-hint">먼저 ‘불러오기’를 눌러 주세요.</div>
            <button id="resetAllBtn" class="btn btn-ghost" type="button" onclick="resetAllSettings()" title="Owner/Repo/Branch/Token 저장값을 초기화합니다">
              설정 초기화
            </button>
            <button id="loadBtn" class="btn btn-primary" onclick="loadAllFiles()">불러오기</button>
          </div>
        </div>

        <!-- 일괄등록 -->
        <div class="box">
          <div class="box-title">
            <span>일괄등록</span>
            <span class="hint-mini">등록 반영 = 자동 분류 + 즉시 저장</span>
          </div>

          <div class="form-group">
            <label>등록 반영 엑셀 파일</label>

            <input type="file" id="bulkFile" accept=".xlsx,.xls" multiple class="hidden" />

            <div class="file-panel" id="fileDropZone" title="이 박스에 파일을 끌어다 놓으시면 추가됩니다">
              <div class="file-panel-head">
                <div class="file-panel-title">
                  선택 파일 <span class="count" id="selectedFileCount">0</span>
                </div>
                <div class="file-panel-actions">
                  <button class="btn btn-ghost" id="pickFilesBtn" type="button" onclick="triggerFilePick()" disabled>파일 추가</button>
                  <button class="btn btn-ghost" id="bulkResetBtn" type="button" onclick="resetBulkUpload()" disabled>초기화</button>
                </div>
              </div>

              <div id="selectedFiles" class="muted">선택된 파일 없음</div>
              <div class="field-help">
                여러 번 추가할 수 있습니다. 일부 파일만 제외하려면 각 파일의 ×를 눌러 주세요.<br>
                <span class="pill">드래그</span>파일을 이 박스에 끌어다 놓으셔도 추가됩니다.
              </div>
            </div>
          </div>

          <div class="toolbar">
            <!-- ✅ 버튼명 변경 + 확인 팝업 래퍼 함수 연결 -->
            <button class="btn btn-primary" id="bulkBtn" onclick="confirmAndImportBulkExcelAutoSave()" disabled>등록 반영</button>
          </div>
        </div>

      </div>

      <!-- 상태 (전체 폭) -->
      <div id="statusMsg" class="status" role="status" aria-live="polite" title="클릭하시면 닫힙니다"></div>

      <!-- 그리드(불러온 데이터) -->
      <div id="afterLoad" class="box" style="display:none;">
        <div class="grid-head">
          <div class="tabs" aria-label="대상 탭">
            <button id="tabDeceased" class="tab-btn active" onclick="selectTarget('deceased')">추모의집</button>
            <button id="tabNature" class="tab-btn" onclick="selectTarget('nature')">자연장지</button>
          </div>
          <div class="grid-meta" id="gridMeta">최근 20건 표시</div>
        </div>

        <div id="hotContainer"></div>
      </div>
    </div>
  </div>

  <!-- Failure Log Modal -->
  <div id="logModalBackdrop" class="modal-backdrop" role="dialog" aria-modal="true">
    <div class="modal">
      <div class="modal-head">
        <div class="modal-title" id="logModalTitle">등록 반영 실패 로그</div>
        <button class="btn btn-ghost" style="padding:8px 10px; min-height:32px;" onclick="closeLogModal()">닫기</button>
      </div>
      <div class="modal-body" id="logModalBody"></div>
      <div class="modal-foot">
        <button class="btn btn-primary" onclick="closeLogModal()">확인</button>
      </div>
    </div>
  </div>

  <script>
    // ===== 설정 =====
    const FILES = {
      deceased: "data/deceased_data.xlsx",
      nature: "data/nature_data.xlsx"
    };
    const GRID_LIMIT = 20;

    // ===== 상태 =====
    let hot = null;
    let fileKey = "deceased";
    let isBusy = false;
    let isLoaded = false;
    let loadedAtText = "";

    // ✅ 업로드 파일 상태(삭제 가능한 리스트로 직접 관리)
    let selectedFiles = []; // [{id, file}]

    // 실패 로그(모달 전용)
    let importFailLog = [];

    const DETECT_HINT = [
      "힌트(번호 규칙):",
      " - 추모의집: '...추모의집-62실-개인단-21908'",
      " - 자연장지: '잔디장-2-9-0108'",
      "판별 규칙(요약):",
      " - '추모의집' 또는 '00실' 포함 → 추모의집",
      " - '잔디장/수목장/자연장' 포함 또는 '이름-숫자-숫자-4자리' 형태 → 자연장지",
      " - 끝자리 숫자 5자리 → 추모의집 / 4자리 → 자연장지(보조)"
    ].join("\n");

    // 데이터셋(2개 파일 동시 관리)
    const DATASETS = {
      deceased: {
        label: "추모의집",
        path: FILES.deceased,
        loaded: false,
        sha: "",
        headers: [],
        rows: [],
        highlight: new Set(),
      },
      nature: {
        label: "자연장지",
        path: FILES.nature,
        loaded: false,
        sha: "",
        headers: [],
        rows: [],
        highlight: new Set(),
      }
    };
    const ds = (k = fileKey) => DATASETS[k];

    window.onload = () => {
      const savedOwner = localStorage.getItem("gh_owner");
      const savedRepo  = localStorage.getItem("gh_repo");
      const savedBranch= localStorage.getItem("gh_branch");
      const savedToken = localStorage.getItem("gh_token");
      const savedTarget = localStorage.getItem("gh_target");
      const savedLoadedAt = localStorage.getItem("gh_loaded_at");

      if (savedOwner) document.getElementById("owner").value = savedOwner;
      if (savedRepo)  document.getElementById("repo").value  = savedRepo;
      document.getElementById("branch").value = savedBranch || "main";
      if (savedToken) document.getElementById("token").value = savedToken;
      if (savedTarget === "nature") fileKey = "nature";

      selectTarget(fileKey, true);
      setLoaded(false);
      updateTopBadges(false, savedLoadedAt || "", "", document.getElementById("branch").value.trim() || "main");

      ["owner","repo","token","branch"].forEach(id=>{
        const el = document.getElementById(id);
        el?.addEventListener("keydown", (e)=>{
          if(e.key === "Enter") loadAllFiles();
        });
      });

      document.getElementById("statusMsg")?.addEventListener("click", ()=>{
        const el = document.getElementById("statusMsg");
        el.style.display = "none";
      });

      document.getElementById("bulkFile")?.addEventListener("change", (e) => {
        const input = e.target;
        const files = Array.from(input.files || []);
        if (!files.length) return;

        addSelectedFiles(files);
        input.value = "";

        renderSelectedFiles();
        updateBulkButtonState();
      });

      // ✅ 드래그 앤 드롭
      const dz = document.getElementById("fileDropZone");
      if (dz){
        const stop = (e)=>{ e.preventDefault(); e.stopPropagation(); };
        ["dragenter","dragover"].forEach(evt=>{
          dz.addEventListener(evt, (e)=>{
            stop(e);
            if (!isLoaded || isBusy) return;
            dz.classList.add("drop-ready");
          });
        });
        ["dragleave","drop"].forEach(evt=>{
          dz.addEventListener(evt, (e)=>{
            stop(e);
            dz.classList.remove("drop-ready");
          });
        });
        dz.addEventListener("drop", (e)=>{
          if (!isLoaded || isBusy) return;
          const files = Array.from(e.dataTransfer?.files || []).filter(f=>{
            const lower = (f.name || "").toLowerCase();
            return lower.endsWith(".xlsx") || lower.endsWith(".xls");
          });
          if (!files.length) return;
          addSelectedFiles(files);
          renderSelectedFiles();
          updateBulkButtonState();
        });
      }

      renderSelectedFiles();
      updateBulkButtonState();
    };

    function toggleToken(){
      const input = document.getElementById("token");
      const btn = document.getElementById("tokenToggleBtn");
      if(!input || !btn) return;

      const isPw = input.type === "password";
      input.type = isPw ? "text" : "password";
      btn.textContent = isPw ? "가리기" : "보기";
    }

    function clearSavedToken(){
      localStorage.removeItem("gh_token");
      const t = document.getElementById("token");
      if (t) t.value = "";
      showStatus("저장된 토큰을 삭제하였습니다(이 브라우저).", "success");
    }

    function resetAllSettings(){
      ["gh_owner","gh_repo","gh_branch","gh_token","gh_target","gh_loaded_at"].forEach(k=>localStorage.removeItem(k));
      ["owner","repo","token"].forEach(id=>{
        const el = document.getElementById(id);
        if (el) el.value = "";
      });
      const b = document.getElementById("branch");
      if (b) b.value = "main";
      fileKey = "deceased";
      selectTarget(fileKey, true);
      setLoaded(false);
      updateTopBadges(false, "", "", "main");
      resetBulkUpload();
      showStatus("설정이 초기화되었습니다.", "success");
    }

    function pad2(n){ return String(n).padStart(2,"0"); }
    function formatLoadedAt(d){
      const yyyy = d.getFullYear();
      const mm = pad2(d.getMonth()+1);
      const dd = pad2(d.getDate());
      const hh = pad2(d.getHours());
      const mi = pad2(d.getMinutes());
      return `${yyyy}-${mm}-${dd} ${hh}:${mi}`;
    }

    function norm(s) {
      return String(s ?? "")
        .replace(/\s+/g, "")
        .replace(/[–—]/g, "-")
        .toLowerCase();
    }
    function escapeHtml(s) {
      return String(s ?? "")
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }
    function escapeHtmlWithBr(s){
      return escapeHtml(s).replaceAll("\n","<br>");
    }
    function formatBytes(bytes){
      const n = Number(bytes || 0);
      if (!isFinite(n) || n <= 0) return "0 B";
      const units = ["B","KB","MB","GB"];
      let v = n, i = 0;
      while (v >= 1024 && i < units.length - 1){
        v = v / 1024;
        i++;
      }
      const fixed = (i === 0) ? String(Math.round(v)) : v.toFixed(1);
      return `${fixed} ${units[i]}`;
    }

    function normalizeDate(input) {
      const raw = String(input ?? "").trim();
      if (!raw) return "";
      const onlyNum = raw.replace(/[^0-9]/g, "");
      if (onlyNum.length === 8) {
        const y = onlyNum.slice(0,4), m = onlyNum.slice(4,6), d = onlyNum.slice(6,8);
        return `${y}-${m}-${d}`;
      }
      const cleaned = raw.replace(/\./g, "-").replace(/\//g, "-");
      const parts = cleaned.split("-").map(p => p.trim()).filter(Boolean);
      if (parts.length >= 3) {
        let [y,m,d] = parts;
        if (y.length === 2) y = "20" + y;
        m = String(parseInt(m,10)).padStart(2,"0");
        d = String(parseInt(d,10)).padStart(2,"0");
        if (!/^\d{4}$/.test(y) || m === "NaN" || d === "NaN") return "";
        return `${y}-${m}-${d}`;
      }
      return "";
    }

    function findHeaderIndex(hs, candidates) {
      const list = hs.map(norm);
      for (const cand of candidates) {
        const idx = list.indexOf(norm(cand));
        if (idx !== -1) return idx;
      }
      return -1;
    }

    function uint8ArrayToBase64(u8) {
      let binary = "";
      const chunkSize = 0x8000;
      for (let i = 0; i < u8.length; i += chunkSize) {
        const chunk = u8.subarray(i, i + chunkSize);
        binary += String.fromCharCode.apply(null, chunk);
      }
      return btoa(binary);
    }

    function getCellByHeader(rowObj, candidates) {
      const keys = Object.keys(rowObj || {});
      const map = new Map(keys.map(k => [norm(k), k]));
      for (const c of candidates) {
        const key = map.get(norm(c));
        if (key !== undefined) return rowObj[key];
      }
      return "";
    }

    function noHeaderCandidatesFor(key){
      return (key === "deceased")
        ? ["봉안번호","봉안 번호","봉안no","봉안No","번호","관리번호"]
        : ["자연장번호","자연장 번호","자연장no","자연장No","번호","관리번호"];
    }

    function showStatus(msg, type) {
      const el = document.getElementById("statusMsg");
      el.textContent = (msg || "") + "\n(클릭하시면 닫힙니다)";
      el.className = "status " + type;
      el.style.display = "block";
      if (type === "success") setTimeout(() => (el.style.display = "none"), 2500);
    }

    function setBusy(b) {
      isBusy = b;
      document.getElementById("loadBtn").disabled = b;
      document.getElementById("resetAllBtn").disabled = b;

      document.getElementById("bulkResetBtn").disabled = b || !isLoaded;
      document.getElementById("pickFilesBtn").disabled = b || !isLoaded;

      document.getElementById("tabDeceased").disabled = b || !isLoaded;
      document.getElementById("tabNature").disabled = b || !isLoaded;

      updateBulkButtonState();
    }

    function setLoaded(v){
      isLoaded = v;
      document.getElementById("afterLoad").style.display = v ? "block" : "none";
      showLoadHint(!v);

      document.getElementById("bulkResetBtn").disabled = !v || isBusy;
      document.getElementById("pickFilesBtn").disabled = !v || isBusy;

      document.getElementById("tabDeceased").disabled = !v || isBusy;
      document.getElementById("tabNature").disabled = !v || isBusy;

      updateBulkButtonState();
      setBusy(isBusy);
    }

    function showLoadHint(show){
      const el = document.getElementById("loadHint");
      el.style.display = show ? "inline-flex" : "none";
    }

    function updateTopBadges(show, loadedAt, loadedFilesText, branchText){
      const owner = document.getElementById("owner").value.trim();
      const repo  = document.getElementById("repo").value.trim();
      const branch= branchText || document.getElementById("branch").value.trim() || "main";

      const bOwner = document.getElementById("badgeOwner");
      const bRepo  = document.getElementById("badgeRepo");
      const bBranch= document.getElementById("badgeBranch");
      const bLoaded= document.getElementById("badgeLoadedAt");
      const bFiles = document.getElementById("badgeLoadedFiles");

      if (!show){
        bOwner.classList.add("hidden");
        bRepo.classList.add("hidden");
        bBranch.classList.add("hidden");
        bLoaded.classList.add("hidden");
        bFiles.classList.add("hidden");
        return;
      }

      bOwner.querySelector("b").textContent = owner || "-";
      bRepo.querySelector("b").textContent  = repo  || "-";
      bBranch.querySelector("b").textContent = branch || "-";
      bLoaded.querySelector("b").textContent = loadedAt || "-";
      bFiles.querySelector("b").textContent  = loadedFilesText || "-";

      bOwner.classList.remove("hidden");
      bRepo.classList.remove("hidden");
      bBranch.classList.remove("hidden");
      bLoaded.classList.remove("hidden");
      bFiles.classList.remove("hidden");
    }

    function selectTarget(target, isInit=false) {
      fileKey = target;
      localStorage.setItem("gh_target", fileKey);

      document.getElementById("tabDeceased").classList.toggle("active", fileKey === "deceased");
      document.getElementById("tabNature").classList.toggle("active", fileKey === "nature");

      if (isLoaded) {
        const total = ds(fileKey).rows.length;
        document.getElementById("gridMeta").textContent =
          `${ds(fileKey).label} · 최근 ${GRID_LIMIT}건 표시 (총 ${total}건)`;
      } else {
        document.getElementById("gridMeta").textContent = `${ds(fileKey).label} · 최근 ${GRID_LIMIT}건 표시`;
      }

      if (isLoaded) renderGridForCurrentTarget(false);

      if (!isInit && isLoaded) {
        const loadedFilesText = `추모의집 ${ds("deceased").rows.length}건 / 자연장지 ${ds("nature").rows.length}건`;
        updateTopBadges(true, loadedAtText, loadedFilesText, document.getElementById("branch").value.trim() || "main");
      }
    }

    function getInputs() {
      const owner = document.getElementById("owner").value.trim();
      const repo  = document.getElementById("repo").value.trim();
      const token = document.getElementById("token").value.trim();
      const branch = (document.getElementById("branch").value.trim() || "main");
      return { owner, repo, token, branch };
    }

    function saveInputsToLocalStorage({owner, repo, token, branch}) {
      localStorage.setItem("gh_owner", owner);
      localStorage.setItem("gh_repo", repo);
      localStorage.setItem("gh_branch", branch || "main");
      localStorage.setItem("gh_token", token);
    }

    function buildContentsUrl(owner, repo, path, branch) {
      return `https://api.github.com/repos/${owner}/${repo}/contents/${encodeURI(path)}?ref=${encodeURIComponent(branch)}`;
    }

    function makeFileId(file){
      return `${file.name}__${file.size}__${file.lastModified}`;
    }

    function triggerFilePick(){
      if (!isLoaded || isBusy) return;
      document.getElementById("bulkFile")?.click();
    }

    function addSelectedFiles(files){
      const exist = new Set(selectedFiles.map(x => x.id));
      for (const f of files){
        const id = makeFileId(f);
        if (exist.has(id)) continue;
        selectedFiles.push({ id, file: f });
        exist.add(id);
      }
    }

    function removeSelectedFile(id){
      selectedFiles = selectedFiles.filter(x => x.id !== id);
      renderSelectedFiles();
      updateBulkButtonState();
    }

    function renderSelectedFiles(){
      const box = document.getElementById("selectedFiles");
      const cnt = document.getElementById("selectedFileCount");
      cnt.textContent = String(selectedFiles.length);

      if (!selectedFiles.length){
        box.innerHTML = `<span class="muted">선택된 파일 없음</span>`;
        return;
      }

      const items = selectedFiles.map(({id, file}) => {
        return `
          <li>
            <div class="file-left">
              <div class="file-name" title="${escapeHtml(file.name)}">${escapeHtml(file.name)}</div>
              <div class="file-sub">
                <span class="mono">${escapeHtml(formatBytes(file.size))}</span>
                <span class="mono">${escapeHtml(new Date(file.lastModified).toLocaleString())}</span>
              </div>
            </div>
            <button class="x-btn" type="button" title="목록에서 제거" onclick="removeSelectedFile('${id}')">×</button>
          </li>
        `;
      }).join("");

      box.innerHTML = `<ul class="file-list">${items}</ul>`;
    }

    function updateBulkButtonState(){
      const btn = document.getElementById("bulkBtn");
      if (!btn) return;
      btn.disabled = (!isLoaded || isBusy || selectedFiles.length === 0);
    }

    function resetBulkUpload(){
      selectedFiles = [];
      renderSelectedFiles();
      updateBulkButtonState();
      if (isLoaded) showStatus("선택 파일 목록이 초기화되었습니다.", "success");
    }

    // ✅ 등록 반영 클릭 시 확인 팝업(취소 가능)
    function confirmAndImportBulkExcelAutoSave(){
      if (!isLoaded) {
        showLoadHint(true);
        setLoaded(false);
        showStatus("먼저 ‘불러오기’를 눌러 주세요.", "error");
        return;
      }
      if (isBusy) return;

      if (!selectedFiles.length){
        showStatus("등록 반영할 파일을 추가해 주세요.", "error");
        return;
      }

      const ok = window.confirm(
        "등록 반영을 진행하시겠습니까?\n\n" +
        "선택하신 엑셀 파일을 분석하여 추모의집/자연장지 데이터에 즉시 저장합니다.\n" +
        "계속 진행하시려면 [확인], 취소하시려면 [취소]를 선택해 주세요."
      );

      if (!ok){
        showStatus("등록 반영이 취소되었습니다.", "success");
        return;
      }

      importBulkExcelAutoSave();
    }

    async function fetchXlsxFromGitHub({owner, repo, token, branch}, path){
      const apiUrl = buildContentsUrl(owner, repo, path, branch);

      const metaRes = await fetch(apiUrl, {
        headers: { "Authorization": `Bearer ${token}`, "Accept": "application/vnd.github+json" }
      });
      if (!metaRes.ok) {
        const txt = await metaRes.text();
        throw new Error(`메타 조회 실패: ${path} (${metaRes.status})\n${txt}`);
      }
      const meta = await metaRes.json();
      if (Array.isArray(meta)) throw new Error(`경로가 폴더로 인식됨: ${path}`);
      if (!meta.download_url) throw new Error(`download_url 없음: ${path}`);

      const fileRes = await fetch(meta.download_url);
      if (!fileRes.ok) {
        const txt = await fileRes.text();
        throw new Error(`다운로드 실패: ${path} (${fileRes.status})\n${txt}`);
      }

      const buf = await fileRes.arrayBuffer();
      const bytes = new Uint8Array(buf);

      const wb = XLSX.read(bytes, { type: "array" });
      const ws = wb.Sheets[wb.SheetNames[0]];
      const aoa = XLSX.utils.sheet_to_json(ws, { header: 1, defval: "" });

      return { sha: meta.sha || "", aoa };
    }

    function normalizeLoadedDataset(key, aoa){
      const d = ds(key);
      d.headers = (aoa && aoa.length > 0) ? aoa[0].map(h => String(h ?? "").trim()) : [];
      d.rows = (aoa && aoa.length > 1) ? aoa.slice(1) : [];

      if (key === "deceased") {
        const idxReturn = findHeaderIndex(d.headers, ["반환일자","반환 일자","반환일"]);
        if (idxReturn === -1) d.headers.push("반환일자");
        for (const row of d.rows) while (row.length < d.headers.length) row.push("");
      }

      d.highlight = new Set();
      d.loaded = true;
    }

    function renderGridForCurrentTarget(){
      const cur = ds(fileKey);
      const container = document.getElementById("hotContainer");
      container.innerHTML = "";

      const headers = cur.headers || [];
      const rows = cur.rows || [];
      const viewRows = rows.slice(-GRID_LIMIT);

      if (hot) { hot.destroy(); hot = null; }

      hot = new Handsontable(container, {
        data: viewRows,
        rowHeaders: true,
        colHeaders: headers,
        height: 560,
        width: "100%",
        stretchH: "all",
        licenseKey: "non-commercial-and-evaluation",
        readOnly: true,
        contextMenu: false,
        manualColumnResize: true,
        manualRowResize: true,
        filters: true,
        dropdownMenu: true,
        cells: function (row, col) {
          const props = {};
          const startGlobal = Math.max(0, rows.length - GRID_LIMIT);
          const globalIdx = startGlobal + row;
          if (cur.highlight.has(globalIdx)) {
            props.className = (props.className ? props.className + " " : "") + "hot-row-highlight";
          }
          return props;
        }
      });

      setTimeout(() => { hot.render(); hot.refreshDimensions(); }, 0);
    }

    async function loadAllFiles() {
      const inputs = getInputs();
      const { owner, repo, token, branch } = inputs;

      if (!owner || !repo || !token) {
        showStatus("Owner / Repo / Token을 모두 입력해 주세요.", "error");
        setLoaded(false);
        return;
      }

      saveInputsToLocalStorage({owner, repo, token, branch});
      setBusy(true);
      showStatus("추모의집/자연장지 데이터를 불러오는 중입니다...", "loading");

      try {
        DATASETS.deceased.loaded = false;
        DATASETS.nature.loaded = false;

        const tasks = [
          fetchXlsxFromGitHub(inputs, DATASETS.deceased.path).then(res => ({ key:"deceased", ...res })),
          fetchXlsxFromGitHub(inputs, DATASETS.nature.path).then(res => ({ key:"nature", ...res }))
        ];

        const results = await Promise.allSettled(tasks);

        const errors = [];
        for (const r of results){
          if (r.status === "rejected") errors.push(r.reason?.message || String(r.reason));
          else {
            const { key, sha, aoa } = r.value;
            ds(key).sha = sha;
            normalizeLoadedDataset(key, aoa);
          }
        }

        if (errors.length){
          setLoaded(false);
          throw new Error("로드에 실패하였습니다:\n" + errors.join("\n\n"));
        }

        const now = new Date();
        loadedAtText = formatLoadedAt(now);
        localStorage.setItem("gh_loaded_at", loadedAtText);

        setLoaded(true);

        const loadedFilesText = `추모의집 ${ds("deceased").rows.length}건 / 자연장지 ${ds("nature").rows.length}건`;
        updateTopBadges(true, loadedAtText, loadedFilesText, branch);

        showStatus("로드가 완료되었습니다.", "success");

        const total = ds(fileKey).rows.length;
        document.getElementById("gridMeta").textContent =
          `${ds(fileKey).label} · 최근 ${GRID_LIMIT}건 표시 (총 ${total}건)`;

        renderGridForCurrentTarget();

      } catch (e) {
        setLoaded(false);
        showStatus(e.message || String(e), "error");
      } finally {
        setBusy(false);
      }
    }

    function detectTargetByNo(noRaw){
      const s = String(noRaw ?? "").trim();
      if (!s) return null;

      if (s.includes("추모의집")) return "deceased";
      if (s.includes("잔디장") || s.includes("수목장") || s.includes("자연장")) return "nature";

      if (/-\d{1,3}실-/.test(s) || /\b\d{1,3}실\b/.test(s) || /\d{1,3}실/.test(s)) return "deceased";
      if (/^[^-]+-\d+-\d+-\d{4}$/.test(s)) return "nature";

      const m = s.match(/(\d+)\s*$/);
      if (m){
        const len = m[1].length;
        if (len === 5) return "deceased";
        if (len === 4) return "nature";
      }
      return null;
    }

    function detectTemplateTypeByHeaders(rowsObj){
      const keys = new Set();
      for (const r of rowsObj || []){
        Object.keys(r || {}).forEach(k => keys.add(norm(k)));
        if (keys.size > 30) break;
      }
      const hasDe = ["봉안번호","봉안 번호","봉안no","봉안No"].some(x => keys.has(norm(x)));
      const hasNa = ["자연장번호","자연장 번호","자연장no","자연장No"].some(x => keys.has(norm(x)));
      if (hasDe && !hasNa) return "deceased";
      if (hasNa && !hasDe) return "nature";
      if (hasDe && hasNa) return "mixed";
      return "unknown";
    }

    function isMeaningfulRow(rowObj){
      const noRaw = String(getCellByHeader(rowObj, ["봉안번호","봉안 번호","자연장번호","자연장 번호","번호","관리번호"])).trim();
      const deceased = String(getCellByHeader(rowObj, ["사망자명","고인명","고인","사망자"])).trim();
      const applicant = String(getCellByHeader(rowObj, ["신청자명","신청자","사용자명","계약자명"])).trim();
      const inDateRaw = String(getCellByHeader(rowObj, ["안치일자","안치 일자","안치일"])).trim();
      const returnRaw = String(getCellByHeader(rowObj, ["반환일자","반환 일자","반환일"])).trim();

      return !!(noRaw || deceased || applicant || inDateRaw || returnRaw);
    }

    // ✅ 자연장지 업로드 2번행(예시행) 스킵 + 구조행 스킵
    function shouldSkipStructuralRow(templateType, idx, lastIdx, rowObj){
      // 자연장지 예시행: 번호 없음 + 사망자 '이름' + 신청자 '이름' => 무조건 무시
      if (templateType === "nature") {
        const noRaw = String(getCellByHeader(rowObj, ["자연장번호","자연장 번호","번호","관리번호","봉안번호","봉안 번호"])).trim();
        const deceased = String(getCellByHeader(rowObj, ["사망자명","고인명","고인","사망자"])).trim();
        const applicant = String(getCellByHeader(rowObj, ["신청자명","신청자","사용자명","계약자명"])).trim();

        if (!noRaw && norm(deceased) === norm("이름") && norm(applicant) === norm("이름")) {
          return true;
        }
      }

      const meaningful = isMeaningfulRow(rowObj);

      if (!meaningful){
        if (templateType === "nature"){
          if (idx === 0) return true;
          if (idx === lastIdx) return true;
        } else if (templateType === "deceased"){
          if (idx === lastIdx) return true;
        } else {
          if (idx === 0 || idx === lastIdx) return true;
        }
      }
      if (!meaningful) return true;
      return false;
    }

    function findHeaderIndex(hs, candidates) {
      const list = hs.map(norm);
      for (const cand of candidates) {
        const idx = list.indexOf(norm(cand));
        if (idx !== -1) return idx;
      }
      return -1;
    }

    function findExactMatchRowDeceased(noVal, deceasedVal, applicantVal, rowsOverride=null, headersOverride=null) {
      const d = ds("deceased");
      const rows = rowsOverride || d.rows;
      const headers = headersOverride || d.headers;

      const idxNo = findHeaderIndex(headers, ["봉안번호","봉안 번호","봉안no","봉안No","번호","관리번호"]);
      const idxDe = findHeaderIndex(headers, ["사망자명","고인명","고인","사망자"]);
      const idxAp = findHeaderIndex(headers, ["신청자명","신청자","사용자명","계약자명"]);
      const idxReturn = findHeaderIndex(headers, ["반환일자","반환 일자","반환일"]);

      const missing = [];
      if (idxNo === -1) missing.push("봉안번호");
      if (idxDe === -1) missing.push("사망자명");
      if (idxAp === -1) missing.push("신청자명");
      if (idxReturn === -1) missing.push("반환일자");
      if (missing.length) throw new Error("헤더를 찾을 수 없습니다: " + missing.join(", "));

      const noN = norm(noVal), deN = norm(deceasedVal), apN = norm(applicantVal);

      for (let r = 0; r < rows.length; r++) {
        const row = rows[r];
        if (norm(row[idxNo]) === noN && norm(row[idxDe]) === deN && norm(row[idxAp]) === apN) {
          const hasReturn = String(row[idxReturn] ?? "").trim() !== "";
          return { found:true, rowIndex:r, idxReturn, hasReturn };
        }
      }
      return { found:false };
    }

    async function putToGitHub(targetKey, mergedAoa, message) {
      const inputs = getInputs();
      const { owner, repo, token, branch } = inputs;
      const d = ds(targetKey);

      const apiUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${encodeURI(d.path)}?ref=${encodeURIComponent(branch)}`;

      const ws = XLSX.utils.aoa_to_sheet(mergedAoa);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, "Sheet1");

      const wbOut = XLSX.write(wb, { bookType: "xlsx", type: "array" });
      const bytes = new Uint8Array(wbOut);
      const contentBase64 = uint8ArrayToBase64(bytes);

      const putBody = { message, content: contentBase64, sha: d.sha, branch };

      const res = await fetch(apiUrl, {
        method: "PUT",
        headers: {
          "Authorization": `Bearer ${token}`,
          "Accept": "application/vnd.github+json",
          "Content-Type": "application/json"
        },
        body: JSON.stringify(putBody)
      });

      if (!res.ok) {
        const txt = await res.text();
        throw new Error(`[${d.label}] 저장 실패 (${res.status})\n${txt}`);
      }

      const resData = await res.json();
      d.sha = resData.content?.sha || d.sha;
    }

    function openLogModal(title){
      document.getElementById("logModalTitle").textContent = title;
      document.getElementById("logModalBackdrop").style.display = "flex";
      renderLogModalBody();
    }

    function closeLogModal(){
      document.getElementById("logModalBackdrop").style.display = "none";
    }

    document.getElementById("logModalBackdrop")?.addEventListener("click", (e) => {
      if (e.target.id === "logModalBackdrop") closeLogModal();
    });

    function parseRowNo(v){
      const n = parseInt(String(v ?? "").replace(/[^0-9]/g,""), 10);
      return Number.isFinite(n) ? n : 999999999;
    }

    function renderLogModalBody(){
      const body = document.getElementById("logModalBody");
      const sectionsHtml = buildFailLogSectionsByFile();
      body.innerHTML = sectionsHtml;
    }

    function buildFailLogSectionsByFile(){
      if (!importFailLog.length){
        return `<div class="muted">실패 로그가 없습니다.</div>`;
      }

      const list = importFailLog.slice();
      const groups = new Map();
      for (const item of list){
        const key = String(item.file || "-");
        if (!groups.has(key)) groups.set(key, []);
        groups.get(key).push(item);
      }

      const fileNames = Array.from(groups.keys()).sort((a,b)=>a.localeCompare(b,"ko"));

      let html = "";
      for (const fn of fileNames){
        const arr = groups.get(fn);
        arr.sort((a,b)=>parseRowNo(a.rowNo) - parseRowNo(b.rowNo));

        html += `
          <div class="file-section">
            <div class="file-section-head">
              <div>${escapeHtml(fn)}</div>
              <div class="mini">${arr.length}건</div>
            </div>
            <table class="q">
              <thead>
                <tr>
                  <th style="width:80px;">행</th>
                  <th style="width:90px;">대상</th>
                  <th style="width:70px;">구분</th>
                  <th style="width:220px;">번호</th>
                  <th style="width:120px;">사망자명</th>
                  <th style="width:120px;">신청자명</th>
                  <th>사유</th>
                </tr>
              </thead>
              <tbody>
        `;

        for (const l of arr){
          html += `
            <tr>
              <td>${escapeHtml(l.rowNo)}</td>
              <td><b>${escapeHtml(l.target || "-")}</b></td>
              <td>${escapeHtml(l.kind || "-")}</td>
              <td><b>${escapeHtml(l.no || "")}</b></td>
              <td>${escapeHtml(l.deceased || "")}</td>
              <td>${escapeHtml(l.applicant || "")}</td>
              <td class="danger">${escapeHtmlWithBr(l.reason || "")}</td>
            </tr>
          `;
        }

        html += `
              </tbody>
            </table>
          </div>
        `;
      }

      return html;
    }

    // ===== 등록 반영: 자동 분류 + 즉시 저장 =====
    async function importBulkExcelAutoSave() {
      if (!isLoaded) {
        showLoadHint(true);
        setLoaded(false);
        showStatus("먼저 ‘불러오기’를 눌러 주세요.", "error");
        return;
      }
      if (isBusy) return;

      if (!selectedFiles.length){
        showStatus("등록 반영할 파일을 추가해 주세요.", "error");
        return;
      }

      setBusy(true);
      showStatus("등록 반영 준비(분석) → 자동 분류 → 즉시 저장 중입니다...", "loading");

      try {
        importFailLog = [];
        const adds = { deceased: [], nature: [] };
        const rets = [];

        const uploadNoSet = { deceased: new Set(), nature: new Set() };
        const uploadRetKeySet = new Set();

        let processed = 0;

        for (const item of selectedFiles){
          const file = item.file;

          const lower = (file.name || "").toLowerCase();
          if (!(lower.endsWith(".xlsx") || lower.endsWith(".xls"))){
            importFailLog.push({ file:file.name, rowNo:"-", target:"-", kind:"-", no:"", deceased:"", applicant:"", reason:"확장자가 .xlsx/.xls가 아닙니다." });
            continue;
          }

          let wb;
          try {
            const buf = await file.arrayBuffer();
            wb = XLSX.read(new Uint8Array(buf), { type: "array" });
          } catch (e) {
            importFailLog.push({ file:file.name, rowNo:"-", target:"-", kind:"-", no:"", deceased:"", applicant:"", reason:"파일 읽기에 실패하였습니다(손상 가능)." });
            continue;
          }

          if (!wb || !wb.SheetNames || wb.SheetNames.length === 0){
            importFailLog.push({ file:file.name, rowNo:"-", target:"-", kind:"-", no:"", deceased:"", applicant:"", reason:"시트가 없습니다." });
            continue;
          }

          const ws = wb.Sheets[wb.SheetNames[0]];
          if (!ws){
            importFailLog.push({ file:file.name, rowNo:"-", target:"-", kind:"-", no:"", deceased:"", applicant:"", reason:"첫 시트 접근에 실패하였습니다." });
            continue;
          }

          const rowsObj = XLSX.utils.sheet_to_json(ws, { defval: "" });

          if (!rowsObj || rowsObj.length === 0){
            importFailLog.push({ file:file.name, rowNo:"-", target:"-", kind:"-", no:"", deceased:"", applicant:"", reason:"데이터가 없습니다(빈 시트)." });
            continue;
          }

          const templateType = detectTemplateTypeByHeaders(rowsObj);
          const lastIndex = rowsObj.length - 1;

          for (let i = 0; i < rowsObj.length; i++) {
            const r = rowsObj[i];
            const rowNo = i + 2;

            if (shouldSkipStructuralRow(templateType, i, lastIndex, r)) continue;
            processed++;

            const noRaw = String(getCellByHeader(r, ["봉안번호","봉안 번호","자연장번호","자연장 번호","번호","관리번호"])).trim();
            const deceased = String(getCellByHeader(r, ["사망자명","고인명","고인","사망자"])).trim();
            const applicant = String(getCellByHeader(r, ["신청자명","신청자","사용자명","계약자명"])).trim();
            const inDateRaw = String(getCellByHeader(r, ["안치일자","안치 일자","안치일"])).trim();
            const returnRaw = String(getCellByHeader(r, ["반환일자","반환 일자","반환일"])).trim();

            if (!noRaw){
              importFailLog.push({ file:file.name, rowNo, target:"-", kind:"-", no:noRaw, deceased, applicant, reason:"번호(봉안/자연장)가 누락되었습니다." });
              continue;
            }

            const targetKey = detectTargetByNo(noRaw);
            if (!targetKey){
              importFailLog.push({
                file:file.name,
                rowNo,
                target:"판별실패",
                kind:"-",
                no:noRaw,
                deceased,
                applicant,
                reason: "번호 패턴으로 대상(추모의집/자연장지) 판별에 실패하였습니다.\n" + DETECT_HINT
              });
              continue;
            }
            const targetLabel = ds(targetKey).label;

            const isReturn = !!String(returnRaw).trim();
            const kind = isReturn ? "반환" : "신규";

            if (isReturn){
              if (targetKey !== "deceased"){
                importFailLog.push({ file:file.name, rowNo, target:targetLabel, kind, no:noRaw, deceased, applicant, reason:"자연장지는 반환 처리가 불가합니다." });
                continue;
              }
              if (!deceased || !applicant){
                importFailLog.push({ file:file.name, rowNo, target:targetLabel, kind, no:noRaw, deceased, applicant, reason:"필수값 누락(사망자명/신청자명)으로 반환 처리 불가합니다." });
                continue;
              }
              const returnDate = normalizeDate(returnRaw);
              if (!returnDate){
                importFailLog.push({ file:file.name, rowNo, target:targetLabel, kind, no:noRaw, deceased, applicant, reason:"반환일자 형식이 올바르지 않습니다." });
                continue;
              }

              const key3 = norm(noRaw) + "|" + norm(deceased) + "|" + norm(applicant);
              if (uploadRetKeySet.has(key3)){
                importFailLog.push({ file:file.name, rowNo, target:targetLabel, kind, no:noRaw, deceased, applicant, reason:"업로드 파일(전체) 내 반환 항목이 중복되었습니다(번호/사망자/신청자)." });
                continue;
              }
              uploadRetKeySet.add(key3);

              rets.push({ file:file.name, rowNo, no:noRaw, deceased, applicant, returnDate });
              continue;
            }

            // 신규
            if (!deceased || !applicant){
              importFailLog.push({ file:file.name, rowNo, target:targetLabel, kind, no:noRaw, deceased, applicant, reason:"필수값이 누락되었습니다(사망자명/신청자명)." });
              continue;
            }
            if (!inDateRaw){
              importFailLog.push({ file:file.name, rowNo, target:targetLabel, kind, no:noRaw, deceased, applicant, reason:"안치일자가 누락되었습니다(신규)." });
              continue;
            }
            const inDate = normalizeDate(inDateRaw);
            if (!inDate){
              importFailLog.push({ file:file.name, rowNo, target:targetLabel, kind, no:noRaw, deceased, applicant, reason:"안치일자 형식이 올바르지 않습니다(신규)." });
              continue;
            }

            const vNo = norm(noRaw);
            if (uploadNoSet[targetKey].has(vNo)){
              importFailLog.push({ file:file.name, rowNo, target:targetLabel, kind, no:noRaw, deceased, applicant, reason:"업로드 파일(전체) 내 동일 번호가 중복되었습니다." });
              continue;
            }
            uploadNoSet[targetKey].add(vNo);

            adds[targetKey].push({ file:file.name, rowNo, inDate, no:noRaw, deceased, applicant });
          }
        }

        if (processed === 0){
          showStatus("등록 반영할 데이터가 없습니다(예외/빈 행만 존재).", "error");
          return;
        }

        const next = {
          deceased: { headers: ds("deceased").headers.slice(), rows: ds("deceased").rows.map(r=>r.slice()), highlight: new Set() },
          nature:   { headers: ds("nature").headers.slice(),   rows: ds("nature").rows.map(r=>r.slice()),   highlight: new Set() }
        };

        // ✅ 추모의집 신규 중복 처리:
        // - 동일 번호가 '사용중(반환일자 없음)'이면 신규 금지
        // - 동일 번호가 전부 '반환됨(반환일자 있음)' 상태면 신규 허용
        const applyAdds = (key) => {
          if (!adds[key].length) return 0;

          const headers = next[key].headers;
          const rows = next[key].rows;

          const idxInDate = findHeaderIndex(headers, ["안치일자","안치 일자","안치일"]);
          const idxNo = findHeaderIndex(headers, noHeaderCandidatesFor(key));
          const idxDe = findHeaderIndex(headers, ["사망자명","고인명","고인","사망자"]);
          const idxAp = findHeaderIndex(headers, ["신청자명","신청자","사용자명","계약자명"]);

          const missing = [];
          if (idxInDate === -1) missing.push("안치일자");
          if (idxNo === -1) missing.push(key === "deceased" ? "봉안번호" : "자연장번호");
          if (idxDe === -1) missing.push("사망자명");
          if (idxAp === -1) missing.push("신청자명");

          const idxReturn = (key === "deceased")
            ? findHeaderIndex(headers, ["반환일자","반환 일자","반환일"])
            : -1;
          if (key === "deceased" && idxReturn === -1) missing.push("반환일자");

          if (missing.length) throw new Error(`[${ds(key).label}] 헤더를 찾을 수 없습니다: ${missing.join(", ")}`);

          // 번호 상태 맵
          const noStatus = new Map();
          if (key === "deceased") {
            for (const row of rows) {
              const vv = norm(row[idxNo]);
              if (!vv) continue;

              const hasRet = String(row[idxReturn] ?? "").trim() !== "";
              const cur = noStatus.get(vv) || { hasActive: false, hasReturned: false };

              if (hasRet) cur.hasReturned = true;
              else cur.hasActive = true;

              noStatus.set(vv, cur);
            }
          } else {
            for (const row of rows) {
              const vv = norm(row[idxNo]);
              if (vv) noStatus.set(vv, { hasActive: true, hasReturned: false });
            }
          }

          let added = 0;

          for (const q of adds[key]){
            const vv = norm(q.no);

            if (noStatus.has(vv)){
              if (key !== "deceased"){
                importFailLog.push({
                  file:q.file, rowNo:q.rowNo,
                  target:ds(key).label, kind:"신규",
                  no:q.no, deceased:q.deceased, applicant:q.applicant,
                  reason:"해당 대상 파일의 기존 번호와 중복됩니다."
                });
                continue;
              }

              const st = noStatus.get(vv);
              if (st.hasActive){
                importFailLog.push({
                  file:q.file, rowNo:q.rowNo,
                  target:ds(key).label, kind:"신규",
                  no:q.no, deceased:q.deceased, applicant:q.applicant,
                  reason:"해당 봉안번호는 현재 사용 중입니다(반환일자 없음)."
                });
                continue;
              }
              // hasActive=false => 전부 반환된 상태 => 재사용 신규 허용
            }

            const row = new Array(headers.length).fill("");
            row[idxInDate] = q.inDate;
            row[idxNo] = q.no;
            row[idxDe] = q.deceased;
            row[idxAp] = q.applicant;

            rows.push(row);
            next[key].highlight.add(rows.length - 1);
            added++;

            // 신규로 추가한 행은 사용중 상태로 갱신
            if (key === "deceased") {
              const prev = noStatus.get(vv) || { hasActive: false, hasReturned: false };
              noStatus.set(vv, { hasActive: true, hasReturned: prev.hasReturned });
            } else {
              noStatus.set(vv, { hasActive: true, hasReturned: false });
            }
          }

          return added;
        };

        const applyReturns = () => {
          if (!rets.length) return 0;

          const headers = next.deceased.headers;
          const rows = next.deceased.rows;

          let applied = 0;

          const keySet = new Set();
          for (const q of rets){
            const k = norm(q.no) + "|" + norm(q.deceased) + "|" + norm(q.applicant);
            if (keySet.has(k)){
              importFailLog.push({ file:q.file, rowNo:q.rowNo, target:"추모의집", kind:"반환", no:q.no, deceased:q.deceased, applicant:q.applicant, reason:"업로드 내 반환 항목이 중복되었습니다(번호/사망자/신청자)." });
              continue;
            }
            keySet.add(k);

            let match;
            try {
              match = findExactMatchRowDeceased(q.no, q.deceased, q.applicant, rows, headers);
            } catch (e) {
              importFailLog.push({ file:q.file, rowNo:q.rowNo, target:"추모의집", kind:"반환", no:q.no, deceased:q.deceased, applicant:q.applicant, reason:e.message || "헤더 확인이 필요합니다." });
              continue;
            }

            if (!match.found){
              importFailLog.push({ file:q.file, rowNo:q.rowNo, target:"추모의집", kind:"반환", no:q.no, deceased:q.deceased, applicant:q.applicant, reason:"기존 정보와 일치하는 행을 찾을 수 없습니다(완전일치 필요)." });
              continue;
            }
            if (match.hasReturn){
              importFailLog.push({ file:q.file, rowNo:q.rowNo, target:"추모의집", kind:"반환", no:q.no, deceased:q.deceased, applicant:q.applicant, reason:"이미 반환일자가 등록되어 있습니다." });
              continue;
            }

            rows[match.rowIndex][match.idxReturn] = q.returnDate;
            next.deceased.highlight.add(match.rowIndex);
            applied++;
          }

          return applied;
        };

        const addedDe = applyAdds("deceased");
        const addedNa = applyAdds("nature");
        const retDe = applyReturns();

        const needSaveDe = (addedDe > 0) || (retDe > 0);
        const needSaveNa = (addedNa > 0);

        if (!needSaveDe && !needSaveNa){
          showStatus("저장할 항목이 없습니다. (모두 실패/중복/판별실패)", "error");
          if (importFailLog.length){
            openLogModal("등록 반영 실패 로그");
          }
          return;
        }

        const saveErrors = [];

        try {
          if (needSaveDe){
            const merged = [next.deceased.headers, ...next.deceased.rows];
            await putToGitHub("deceased", merged, `Auto upload save (deceased) new:${addedDe} return:${retDe} ${new Date().toISOString()}`);
          }
        } catch (e) {
          saveErrors.push(e.message || String(e));
        }

        try {
          if (needSaveNa){
            const merged = [next.nature.headers, ...next.nature.rows];
            await putToGitHub("nature", merged, `Auto upload save (nature) new:${addedNa} ${new Date().toISOString()}`);
          }
        } catch (e) {
          saveErrors.push(e.message || String(e));
        }

        if (saveErrors.length){
          showStatus("저장 중 오류가 발생하였습니다.\n" + saveErrors.join("\n\n"), "error");
          return;
        }

        if (needSaveDe){
          ds("deceased").rows = next.deceased.rows;
          ds("deceased").highlight = next.deceased.highlight;
        }
        if (needSaveNa){
          ds("nature").rows = next.nature.rows;
          ds("nature").highlight = next.nature.highlight;
        }

        renderGridForCurrentTarget();

        // 상단 배지/그리드 메타 갱신
        const inputs = getInputs();
        const loadedFilesText = `추모의집 ${ds("deceased").rows.length}건 / 자연장지 ${ds("nature").rows.length}건`;
        updateTopBadges(true, loadedAtText, loadedFilesText, inputs.branch);

        const total = ds(fileKey).rows.length;
        document.getElementById("gridMeta").textContent =
          `${ds(fileKey).label} · 최근 ${GRID_LIMIT}건 표시 (총 ${total}건)`;

        const msg =
          `등록 반영이 완료되었습니다.\n` +
          `추모의집: 신규 ${addedDe} / 반환 ${retDe}\n` +
          `자연장지: 신규 ${addedNa}\n` +
          (importFailLog.length ? `실패 ${importFailLog.length}건(모달에서 확인해 주세요)` : `실패 0건`);
        showStatus(msg, "success");

        if (importFailLog.length){
          openLogModal("등록 반영 실패 로그");
        }

      } catch (e) {
        showStatus(e.message || String(e), "error");
      } finally {
        setBusy(false);
      }
    }
  </script>
</body>
</html>
