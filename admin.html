<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>울산하늘공원 데이터 관리자</title>

  <!-- 파비콘 설정 -->
  <link rel="icon" type="image/x-icon" href="./images/symbol.png">
  <!-- 애플 기기용 아이콘 -->
  <link rel="apple-touch-icon" href="./images/symbol.png">

  <!-- Handsontable -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/handsontable/dist/handsontable.full.min.css" />
  <script src="https://cdn.jsdelivr.net/npm/handsontable/dist/handsontable.full.min.js"></script>

  <!-- XLSX -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <style>
    :root{
      /* Warm Yellow (Soft) Theme */
      --bg:#fffaf0;              /* warm ivory */
      --panel:#ffffff;
      --text:#0f172a;
      --muted:#6b7280;
      --line:#f2e6c7;

      --primary:#f2c94c;         /* soft amber */
      --primary-h:#e9b93a;
      --accent:#ffe9a6;

      --success:#47c997;
      --success-h:#3db987;

      --ghost:#fff4dc;
      --ghost-h:#ffefc6;

      --danger:#b42318;

      --shadow: 0 16px 44px rgba(15, 23, 42, 0.10);
      --radius:16px;
    }

    *{ box-sizing:border-box; }
    body{
      margin:0;
      padding:22px;
      background:
        radial-gradient(1200px 600px at 50% -220px, rgba(242,201,76,0.22), rgba(0,0,0,0)),
        radial-gradient(900px 520px at 10% 10%, rgba(255,233,166,0.25), rgba(0,0,0,0)),
        var(--bg);
      color:var(--text);
      font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Apple SD Gothic Neo", "Noto Sans KR", sans-serif;
      display:flex;
      justify-content:center;
      font-size:16px;
    }

    .container{
      width:100%;
      max-width:1280px;
      background:var(--panel);
      border:1px solid var(--line);
      border-radius:20px;
      box-shadow:var(--shadow);
      overflow:hidden;
    }

    /* Header */
    .header{
      padding:18px 20px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      border-bottom:1px solid var(--line);
      background: linear-gradient(180deg, rgba(242,201,76,0.18), rgba(255,255,255,1));
    }
    .header-left{
      display:flex;
      flex-direction:column;
      gap:10px;
      min-width:0;
    }
    .title{
      font-size:28px;
      font-weight:950;
      letter-spacing:-0.4px;
      margin:0;
      line-height:1.1;
    }

    .badges{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      min-height:34px;
    }
    .badge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:9px 13px;
      border-radius:999px;
      font-size:14px;
      font-weight:850;
      color:#3b2f13;
      background:#fff6da;
      border:1px solid #f2e1b2;
      white-space:nowrap;
    }
    .badge b{ font-weight:950; }
    .badge.hidden{ display:none !important; }

    .header-right{
      display:flex;
      align-items:center;
      gap:12px;
      flex-shrink:0;
    }
    .logo{
      height:44px; /* 우측 상단 로고 크게 */
      width:auto;
      display:block;
    }

    /* Target toggle */
    .seg{
      padding:16px 18px 0;
      display:flex;
      justify-content:center;
    }
    .seg-wrap{
      background:#fff6dc;
      border:1px solid #f2e1b2;
      border-radius:999px;
      padding:5px;
      display:inline-flex;
      gap:5px;
      box-shadow: inset 0 1px 0 rgba(15,23,42,0.04);
    }
    .seg-btn{
      border:0;
      background:transparent;
      cursor:pointer;
      padding:13px 20px;
      border-radius:999px;
      font-weight:950;
      font-size:18px; /* 크게 */
      color:#2b1f09;
      transition:0.18s;
      min-width:160px;
    }
    .seg-btn:disabled{
      opacity:0.55;
      cursor:not-allowed;
    }
    .seg-btn.active{
      background: linear-gradient(180deg, rgba(255,233,166,0.98), rgba(242,201,76,0.88));
      color:#2b1f09;
      box-shadow: 0 10px 20px rgba(242,201,76,0.28);
      border:1px solid rgba(242,201,76,0.40);
    }

    /* Sections */
    .content{
      padding:16px 18px 18px;
    }
    .box{
      background:#fff;
      border:1px solid var(--line);
      border-radius:var(--radius);
      padding:16px;
      margin-bottom:14px;
    }
    .box-title{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      font-weight:950;
      margin-bottom:12px;
      color:#0f172a;
      font-size:17px;
    }
    .hint-mini{
      font-size:14px;
      font-weight:850;
      color:var(--muted);
    }

    .row{
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(260px,1fr));
      gap:12px;
      margin:0;
    }
    .form-group label{
      display:block;
      font-weight:900;
      font-size:14px;
      margin-bottom:8px;
      color:#334155;
    }
    .form-group input{
      width:100%;
      padding:13px 12px;
      border:1px solid var(--line);
      border-radius:14px;
      background:#fff;
      font-size:16px;
      outline:none;
      transition:0.15s;
    }
    .form-group input:focus{
      border-color:#f2d68b;
      box-shadow:0 0 0 5px rgba(242,201,76,0.20);
    }

    .toolbar{
      margin-top:12px;
      display:flex;
      align-items:center;
      justify-content:flex-end;
      gap:10px;
      flex-wrap:wrap;
      position:relative;
    }

    /* Buttons */
    .btn{
      border:1px solid transparent;
      padding:12px 16px;
      border-radius:14px;
      font-size:16px;
      font-weight:950;
      cursor:pointer;
      transition:0.15s;
      display:inline-flex;
      align-items:center;
      gap:8px;
    }
    .btn:disabled{ opacity:0.55; cursor:not-allowed; }
    .btn:hover{ transform: translateY(-1px); }
    .btn:active{ transform: translateY(0px); }
    .btn:focus-visible{
      outline:none;
      box-shadow:0 0 0 5px rgba(242,201,76,0.22);
    }

    .btn-primary{
      background: linear-gradient(180deg, rgba(255,241,194,0.98), rgba(242,201,76,0.88));
      color:#2b1f09;
      border-color: rgba(242,201,76,0.45);
      box-shadow: 0 10px 18px rgba(242,201,76,0.20);
    }
    .btn-primary:hover{ filter:brightness(0.99); }

    .btn-ghost{
      background:var(--ghost);
      border-color:#f2e1b2;
      color:#2b1f09;
    }
    .btn-ghost:hover{ background:var(--ghost-h); }

    .btn-success{
      background: linear-gradient(180deg, rgba(205,255,237,0.96), rgba(71,201,151,0.86));
      color:#0b2a1c;
      border-color: rgba(71,201,151,0.30);
      box-shadow: 0 10px 18px rgba(71,201,151,0.16);
    }
    .btn-success:hover{ filter:brightness(0.99); }

    /* Token input UX */
    .input-with-btn{
      display:flex;
      gap:10px;
      align-items:center;
    }
    .icon-btn{
      border:1px solid #f2e1b2;
      background:#fff6da;
      color:#2b1f09;
      padding:12px 14px;
      border-radius:14px;
      font-weight:950;
      cursor:pointer;
      transition:0.15s;
      white-space:nowrap;
    }
    .icon-btn:hover{ background:#ffefc6; transform: translateY(-1px); }
    .field-help{
      margin-top:8px;
      font-size:13px;
      color:var(--muted);
      font-weight:800;
    }

    /* Load hint (no box, polite, thin, big) */
    .load-hint{
      display:none;
      margin-right:10px;
      font-size:19px;
      font-weight:420;
      color:#8a5a12;
      letter-spacing:-0.2px;
      align-items:center;
      gap:8px;
      white-space:nowrap;
    }
    .load-hint .arrow{
      font-size:20px;
      font-weight:900;
      animation: arrowMove 1s infinite;
      display:inline-block;
    }
    @keyframes arrowMove{
      0%{ transform:translateX(0); opacity:0.55; }
      50%{ transform:translateX(7px); opacity:1; }
      100%{ transform:translateX(0); opacity:0.55; }
    }

    /* Blink load button when not loaded */
    .blink{
      animation: blinkPulse 1.2s infinite;
    }
    @keyframes blinkPulse{
      0%{ transform:translateY(0); box-shadow: 0 10px 18px rgba(242,201,76,0.20); }
      50%{ transform:translateY(-1px); box-shadow: 0 14px 26px rgba(242,201,76,0.32); }
      100%{ transform:translateY(0); box-shadow: 0 10px 18px rgba(242,201,76,0.20); }
    }

    /* Status (sticky toast) */
    .status{
      display:none;
      position: sticky;
      top: 12px;
      z-index: 50;
      margin:10px 0 12px;
      padding:12px 14px;
      border-radius:16px;
      border:1px solid var(--line);
      background: rgba(255,255,255,0.92);
      backdrop-filter: blur(6px);
      color:#111827;
      white-space:pre-wrap;
      font-size:16px;
      cursor:pointer;
    }
    .status.success{ border-color:#c7f3dd; background:#effdf7; color:#14532d; }
    .status.error{ border-color:#fecdd3; background:#fff1f2; color:#7f1d1d; }
    .status.loading{ background:#fff7e1; color:#4b5563; }

    .pill{
      display:inline-block;
      padding:4px 10px;
      border-radius:999px;
      font-size:14px;
      font-weight:900;
      border:1px solid var(--line);
      background:#fff7e1;
      color:#2b1f09;
    }

    table.q{
      width:100%;
      border-collapse:separate;
      border-spacing:0;
      overflow:hidden;
      border:1px solid var(--line);
      border-radius:16px;
      background:#fff;
    }
    table.q th, table.q td{
      border-bottom:1px solid var(--line);
      padding:12px;
      font-size:15px;
      text-align:left;
      vertical-align:middle;
    }
    table.q th{
      background:#fff7e1;
      font-weight:950;
    }
    table.q tr:nth-child(even) td{ background: rgba(255,233,166,0.10); }
    table.q tr:last-child td{ border-bottom:none; }
    .danger{ color:var(--danger); font-weight:900; }

    #hotContainer{
      width:100%;
      height:560px;
      border:1px solid var(--line);
      border-radius:16px;
      overflow:hidden;
      background:#fff;
    }

    .hidden{ display:none !important; }

    /* Grid row highlight */
    .hot-row-highlight{
      background: rgba(242,201,76,0.22) !important;
    }

    /* Modal */
    .modal-backdrop{
      position:fixed;
      inset:0;
      background: rgba(2,6,23,0.38);
      display:none;
      align-items:center;
      justify-content:center;
      padding:18px;
      z-index:9999;
    }
    .modal{
      width:100%;
      max-width:520px;
      background:#fff;
      border-radius:20px;
      border:1px solid var(--line);
      box-shadow: 0 22px 70px rgba(2,6,23,0.30);
      overflow:hidden;
    }
    .modal-head{
      padding:14px 16px;
      border-bottom:1px solid var(--line);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      background: linear-gradient(180deg, rgba(242,201,76,0.14), #fff);
    }
    .modal-title{
      font-size:17px;
      font-weight:950;
      margin:0;
    }
    .modal-body{
      padding:14px 16px;
      color:#0f172a;
      font-size:16px;
      line-height:1.5;
      white-space:pre-wrap;
    }
    .modal-foot{
      padding:14px 16px;
      border-top:1px solid var(--line);
      display:flex;
      justify-content:flex-end;
      gap:10px;
    }

    @media (prefers-reduced-motion: reduce){
      .blink, .load-hint .arrow{ animation:none !important; }
      .btn:hover{ transform:none; }
      .icon-btn:hover{ transform:none; }
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="header">
      <div class="header-left">
        <h1 class="title">울산하늘공원 데이터 관리자</h1>
        <div class="badges">
          <span id="badgeOwner" class="badge hidden">Owner: <b>-</b></span>
          <span id="badgeRepo"  class="badge hidden">Repo: <b>-</b></span>
          <span id="badgeTarget" class="badge hidden">Target: <b>-</b></span>
          <span id="badgeLoadedAt" class="badge hidden">마지막 로드: <b>-</b></span>
        </div>
      </div>
      <div class="header-right">
        <img class="logo" src="./images/ulsan_logo1.png" alt="울산 로고" />
      </div>
    </div>

    <!-- 대상 선택 -->
    <div class="seg">
      <div class="seg-wrap">
        <button id="btnDeceased" class="seg-btn active" onclick="selectTarget('deceased')">추모의집</button>
        <button id="btnNature" class="seg-btn" onclick="selectTarget('nature')">자연장지</button>
      </div>
    </div>

    <div class="content">
      <!-- GitHub 설정 -->
      <div class="box">
        <div class="box-title">
          <span>GitHub 설정</span>
          <span class="hint-mini">데이터를 불러온 뒤 작업해 주세요</span>
        </div>

        <div class="row">
          <div class="form-group">
            <label>GitHub Owner</label>
            <input type="text" id="owner" placeholder="예: UL-SkyPark" />
          </div>
          <div class="form-group">
            <label>Repository</label>
            <input type="text" id="repo" placeholder="예: ulsan-skypark-search" />
          </div>

          <!-- 토큰 입력 UX 개선 -->
          <div class="form-group">
            <label>Access Token</label>
            <div class="input-with-btn">
              <input type="password" id="token" placeholder="ghp_... 또는 fine-grained token" />
              <button type="button" class="icon-btn" onclick="toggleToken()">보기</button>
            </div>
            <div class="field-help">fine-grained token이면 Contents 권한(읽기/쓰기) 확인해줘.</div>
          </div>
        </div>

        <div class="toolbar">
          <div id="loadHint" class="load-hint">
            불러온 정보가 없습니다. 먼저 ‘불러오기’를 눌러주세요.
            <span class="arrow">→</span>
          </div>
          <button id="loadBtn" class="btn btn-primary" onclick="loadFile()">불러오기</button>
        </div>
      </div>

      <!-- 상태 -->
      <div id="statusMsg" class="status" title="클릭하면 닫혀요"></div>

      <!-- 일괄등록 -->
      <div class="box">
        <div class="box-title">
          <span>일괄등록</span>
          <span class="hint-mini">로드 후 업로드 반영이 가능합니다</span>
        </div>

        <div class="row">
          <div class="form-group">
            <label>업로드 엑셀 선택</label>
            <input type="file" id="bulkFile" accept=".xlsx,.xls" />
          </div>
        </div>

        <div class="toolbar">
          <button class="btn btn-ghost" id="bulkResetBtn" onclick="resetBulkUpload()" disabled>업로드 초기화</button>
          <button class="btn btn-primary" id="bulkBtn" onclick="importBulkExcel()" disabled>업로드 반영</button>
        </div>
      </div>

      <!-- 로드 성공 후에만 노출 -->
      <div id="afterLoad" class="hidden">
        <!-- 신규 대기목록 -->
        <div class="box">
          <div class="box-title">
            <span>신규 대기목록 <span class="pill" id="newCount">0건</span></span>
            <span class="hint-mini">저장 전 목록을 확인해 주세요</span>
          </div>
          <div class="toolbar" style="margin-top:0; margin-bottom:10px;">
            <button id="saveNewBtn" class="btn btn-success" onclick="confirmSave('new')" disabled>신규 저장</button>
            <button id="clearNewBtn" class="btn btn-ghost" onclick="clearNewQueue()" disabled>신규 비우기</button>
          </div>
          <div id="newQueueWrap"></div>
          <div id="newMini" style="font-size:14px; color:var(--muted);">신규 대기목록이 비어 있습니다.</div>
        </div>

        <!-- 반환 대기목록(추모의집만) -->
        <div class="box" id="returnQueueBox">
          <div class="box-title">
            <span>반환 대기목록 <span class="pill" id="retCount">0건</span></span>
            <span class="hint-mini">추모의집 대상만 가능합니다</span>
          </div>
          <div class="toolbar" style="margin-top:0; margin-bottom:10px;">
            <button id="saveReturnBtn" class="btn btn-success" onclick="confirmSave('return')" disabled>반환 저장</button>
            <button id="clearReturnBtn" class="btn btn-ghost" onclick="clearReturnQueue()" disabled>반환 비우기</button>
          </div>
          <div id="retQueueWrap"></div>
          <div id="retMini" style="font-size:14px; color:var(--muted);">반환 대기목록이 비어 있습니다.</div>
        </div>

        <!-- 업로드 제외 로그 -->
        <div class="box">
          <div class="box-title">
            <span>업로드 제외 로그 <span class="pill" id="logCount">0건</span></span>
            <span class="hint-mini">누락/중복/형식 오류</span>
          </div>
          <div id="logWrap"></div>
          <div id="logMini" style="font-size:14px; color:var(--muted);">제외된 항목이 없습니다.</div>
        </div>

        <!-- 최근 20건 -->
        <div id="hotContainer"></div>
      </div>
    </div>
  </div>

  <!-- Confirm Modal -->
  <div id="modalBackdrop" class="modal-backdrop" role="dialog" aria-modal="true">
    <div class="modal">
      <div class="modal-head">
        <div class="modal-title" id="modalTitle">확인</div>
        <button class="btn btn-ghost" style="padding:8px 12px;" onclick="closeModal()">닫기</button>
      </div>
      <div class="modal-body" id="modalBody">정말 저장하시겠습니까?</div>
      <div class="modal-foot">
        <button class="btn btn-ghost" onclick="closeModal()">취소</button>
        <button class="btn btn-primary" id="modalOkBtn">확인</button>
      </div>
    </div>
  </div>

  <script>
    // ===== 설정 =====
    const BRANCH = "main";
    const FILES = {
      deceased: "data/deceased_data.xlsx",
      nature: "data/nature_data.xlsx"
    };
    const GRID_LIMIT = 20;

    // ===== 상태 =====
    let hot = null;
    let currentSha = "";
    let headers = [];
    let fileKey = "deceased";
    let isBusy = false;
    let isLoaded = false;

    // 전체 데이터(헤더 제외 본문 전체)
    let allRows = [];

    // 대기목록
    let newQueue = [];
    let returnQueue = [];

    // 업로드 제외 로그
    let importLog = [];

    // 하이라이트(전역 row index 기준)
    let highlightGlobalIdx = new Set();

    window.onload = () => {
      const savedOwner = localStorage.getItem("gh_owner");
      const savedRepo  = localStorage.getItem("gh_repo");
      const savedToken = localStorage.getItem("gh_token");
      const savedTarget = localStorage.getItem("gh_target");
      const savedLoadedAt = localStorage.getItem("gh_loaded_at");

      if (savedOwner) document.getElementById("owner").value = savedOwner;
      if (savedRepo)  document.getElementById("repo").value  = savedRepo;
      if (savedToken) document.getElementById("token").value = savedToken;
      if (savedTarget === "nature") fileKey = "nature";

      selectTarget(fileKey, true);
      renderAllQueues();
      renderImportLog();
      enableBulkButton(false);

      // 로드 전 상태로 시작
      setLoaded(false);
      updateTopBadges(false, savedLoadedAt || "");

      // Enter로 바로 불러오기
      ["owner","repo","token"].forEach(id=>{
        const el = document.getElementById(id);
        el?.addEventListener("keydown", (e)=>{
          if(e.key === "Enter") loadFile();
        });
      });

      // 상태 메시지 클릭하면 닫기
      document.getElementById("statusMsg")?.addEventListener("click", ()=>{
        const el = document.getElementById("statusMsg");
        el.style.display = "none";
      });
    };

    function toggleToken(){
      const input = document.getElementById("token");
      const btn = document.querySelector(".icon-btn");
      if(!input || !btn) return;

      const isPw = input.type === "password";
      input.type = isPw ? "text" : "password";
      btn.textContent = isPw ? "가리기" : "보기";
    }

    // ===== 날짜/시간 =====
    function pad2(n){ return String(n).padStart(2,"0"); }
    function formatLoadedAt(d){
      const yyyy = d.getFullYear();
      const mm = pad2(d.getMonth()+1);
      const dd = pad2(d.getDate());
      const hh = pad2(d.getHours());
      const mi = pad2(d.getMinutes());
      return `${yyyy}-${mm}-${dd} ${hh}:${mi}`;
    }

    // ===== 로드 상태 UI =====
    function setLoaded(v){
      isLoaded = v;
      document.getElementById("afterLoad").classList.toggle("hidden", !v);
      showLoadHint(!v);

      const loadBtn = document.getElementById("loadBtn");
      loadBtn.classList.toggle("blink", !v);

      document.getElementById("bulkResetBtn").disabled = !v;
      setBusy(isBusy);
    }

    function showLoadHint(show){
      const el = document.getElementById("loadHint");
      el.style.display = show ? "inline-flex" : "none";
    }

    function updateTopBadges(show, loadedAtText=""){
      const owner = document.getElementById("owner").value.trim();
      const repo  = document.getElementById("repo").value.trim();
      const targetName = (fileKey === "deceased") ? "추모의집" : "자연장지";

      const bOwner = document.getElementById("badgeOwner");
      const bRepo  = document.getElementById("badgeRepo");
      const bTarget= document.getElementById("badgeTarget");
      const bLoaded= document.getElementById("badgeLoadedAt");

      if (!show){
        bOwner.classList.add("hidden");
        bRepo.classList.add("hidden");
        bTarget.classList.add("hidden");
        bLoaded.classList.add("hidden");
        return;
      }

      bOwner.querySelector("b").textContent = owner || "-";
      bRepo.querySelector("b").textContent  = repo  || "-";
      bTarget.querySelector("b").textContent = targetName;
      bLoaded.querySelector("b").textContent = loadedAtText || "-";

      bOwner.classList.remove("hidden");
      bRepo.classList.remove("hidden");
      bTarget.classList.remove("hidden");
      bLoaded.classList.remove("hidden");
    }

    // ===== 공용 상태 =====
    function showStatus(msg, type) {
      const el = document.getElementById("statusMsg");
      el.textContent = msg + (type === "loading" ? "\n(클릭하면 닫힘)" : "");
      el.className = "status " + type;
      el.style.display = "block";
      if (type === "success") setTimeout(() => (el.style.display = "none"), 2200);
    }

    function setBusy(b) {
      isBusy = b;

      document.getElementById("loadBtn").disabled = b;
      document.getElementById("bulkBtn").disabled = b || !hot;
      document.getElementById("bulkResetBtn").disabled = b || !isLoaded;

      document.getElementById("saveNewBtn").disabled = b || !hot || newQueue.length === 0;
      document.getElementById("clearNewBtn").disabled = b || newQueue.length === 0;

      document.getElementById("saveReturnBtn").disabled = b || !hot || fileKey !== "deceased" || returnQueue.length === 0;
      document.getElementById("clearReturnBtn").disabled = b || fileKey !== "deceased" || returnQueue.length === 0;

      // 대상 버튼 잠금(작업 중 실수 방지)
      document.getElementById("btnDeceased").disabled = b;
      document.getElementById("btnNature").disabled = b;
    }

    function enableBulkButton(enable) {
      const b = document.getElementById("bulkBtn");
      if (b) b.disabled = !enable;
    }

    // ===== 탭(대상) 변경 =====
    function selectTarget(target, isInit=false) {
      fileKey = target;
      localStorage.setItem("gh_target", fileKey);

      document.getElementById("btnDeceased").classList.toggle("active", fileKey === "deceased");
      document.getElementById("btnNature").classList.toggle("active", fileKey === "nature");

      document.getElementById("returnQueueBox").style.display = (fileKey === "deceased") ? "block" : "none";

      // 초기화
      newQueue = [];
      returnQueue = [];
      importLog = [];
      allRows = [];
      highlightGlobalIdx = new Set();
      hot = null;
      headers = [];
      currentSha = "";

      document.getElementById("hotContainer").innerHTML = "";
      renderAllQueues();
      renderImportLog();
      enableBulkButton(false);
      setBusy(false);

      // 로드 상태 해제
      setLoaded(false);
      if (!isInit) updateTopBadges(false, localStorage.getItem("gh_loaded_at") || "");
    }

    // ===== 입력값 =====
    function getInputs() {
      const owner = document.getElementById("owner").value.trim();
      const repo  = document.getElementById("repo").value.trim();
      const token = document.getElementById("token").value.trim();
      const path = FILES[fileKey];
      return { owner, repo, token, path, branch: BRANCH };
    }

    function saveInputsToLocalStorage({owner, repo, token}) {
      localStorage.setItem("gh_owner", owner);
      localStorage.setItem("gh_repo", repo);
      localStorage.setItem("gh_token", token);
    }

    function buildContentsUrl(owner, repo, path, branch) {
      return `https://api.github.com/repos/${owner}/${repo}/contents/${encodeURI(path)}?ref=${encodeURIComponent(branch)}`;
    }

    // ===== 유틸 =====
    function norm(s) {
      return String(s ?? "")
        .replace(/\s+/g, "")
        .replace(/[–—]/g, "-")
        .toLowerCase();
    }
    function escapeHtml(s) {
      return String(s ?? "")
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }
    function normalizeDate(input) {
      const raw = String(input ?? "").trim();
      if (!raw) return "";
      const onlyNum = raw.replace(/[^0-9]/g, "");
      if (onlyNum.length === 8) {
        const y = onlyNum.slice(0,4), m = onlyNum.slice(4,6), d = onlyNum.slice(6,8);
        return `${y}-${m}-${d}`;
      }
      const cleaned = raw.replace(/\./g, "-").replace(/\//g, "-");
      const parts = cleaned.split("-").map(p => p.trim()).filter(Boolean);
      if (parts.length >= 3) {
        let [y,m,d] = parts;
        if (y.length === 2) y = "20" + y;
        m = String(parseInt(m,10)).padStart(2,"0");
        d = String(parseInt(d,10)).padStart(2,"0");
        if (!/^\d{4}$/.test(y) || m === "NaN" || d === "NaN") return "";
        return `${y}-${m}-${d}`;
      }
      return "";
    }
    function findHeaderIndex(hs, candidates) {
      const list = hs.map(norm);
      for (const cand of candidates) {
        const idx = list.indexOf(norm(cand));
        if (idx !== -1) return idx;
      }
      return -1;
    }
    function uint8ArrayToBase64(u8) {
      let binary = "";
      const chunkSize = 0x8000;
      for (let i = 0; i < u8.length; i += chunkSize) {
        const chunk = u8.subarray(i, i + chunkSize);
        binary += String.fromCharCode.apply(null, chunk);
      }
      return btoa(binary);
    }
    function getCellByHeader(rowObj, candidates) {
      const keys = Object.keys(rowObj || {});
      const map = new Map(keys.map(k => [norm(k), k]));
      for (const c of candidates) {
        const key = map.get(norm(c));
        if (key !== undefined) return rowObj[key];
      }
      return "";
    }
    function noHeaderCandidates() {
      return (fileKey === "deceased")
        ? ["봉안번호","봉안 번호","봉안no","봉안No","번호","관리번호"]
        : ["자연장번호","자연장 번호","자연장no","자연장No","번호","관리번호"];
    }

    // ===== 업로드 초기화 =====
    function resetBulkUpload(){
      const input = document.getElementById("bulkFile");
      if (input) input.value = "";
      showStatus("업로드 파일 선택이 초기화되었습니다.", "success");
    }

    // ===== 모달 =====
    function openModal(title, body, onOk){
      const bd = document.getElementById("modalBackdrop");
      document.getElementById("modalTitle").textContent = title;
      document.getElementById("modalBody").textContent = body;

      const okBtn = document.getElementById("modalOkBtn");
      okBtn.onclick = () => { closeModal(); onOk && onOk(); };

      bd.style.display = "flex";
    }
    function closeModal(){
      document.getElementById("modalBackdrop").style.display = "none";
    }
    document.getElementById("modalBackdrop")?.addEventListener("click", (e) => {
      if (e.target.id === "modalBackdrop") closeModal();
    });

    function confirmSave(kind){
      if (!hot){
        showLoadHint(true);
        setLoaded(false);
        showStatus("불러온 정보가 없습니다. 먼저 ‘불러오기’를 눌러주세요.", "error");
        return;
      }
      if (kind === "new"){
        openModal("신규 저장 확인", `신규 대기목록 ${newQueue.length}건을 저장하시겠습니까?\n저장 후에는 최근 20건 그리드에 반영됩니다.`, () => saveNewQueue());
        return;
      }
      if (kind === "return"){
        openModal("반환 저장 확인", `반환 대기목록 ${returnQueue.length}건을 저장하시겠습니까?\n저장 후에는 최근 20건 그리드에 반영됩니다.`, () => saveReturnQueue());
        return;
      }
    }

    // ===== 로그 =====
    function addImportLog(item){ importLog.push(item); }
    function renderImportLog() {
      document.getElementById("logCount").textContent = `${importLog.length}건`;
      const wrap = document.getElementById("logWrap");
      const mini = document.getElementById("logMini");

      if (importLog.length === 0) {
        wrap.innerHTML = "";
        mini.textContent = "제외된 항목이 없습니다.";
        return;
      }

      mini.textContent = "업로드에서 제외된 항목과 사유입니다.";
      let html = `<table class="q"><thead><tr>
        <th style="width:90px;">엑셀행</th>
        <th style="width:90px;">구분</th>
        <th>번호</th>
        <th>사망자명</th>
        <th>신청자명</th>
        <th>제외 사유</th>
      </tr></thead><tbody>`;

      importLog.forEach(l => {
        html += `<tr>
          <td>${escapeHtml(l.rowNo)}</td>
          <td><span class="pill">${escapeHtml(l.kind)}</span></td>
          <td><b>${escapeHtml(l.no || "")}</b></td>
          <td>${escapeHtml(l.deceased || "")}</td>
          <td>${escapeHtml(l.applicant || "")}</td>
          <td class="danger">${escapeHtml(l.reason)}</td>
        </tr>`;
      });

      html += `</tbody></table>`;
      wrap.innerHTML = html;
    }

    // ===== 그리드 초기화/갱신 =====
    function initGrid(aoa) {
      const container = document.getElementById("hotContainer");
      container.innerHTML = "";

      headers = (aoa && aoa.length > 0) ? aoa[0].map(h => String(h ?? "").trim()) : [];
      allRows = (aoa && aoa.length > 1) ? aoa.slice(1) : [];

      // 추모의집: 반환일자 컬럼 없으면 생성
      if (fileKey === "deceased") {
        const idxReturn = findHeaderIndex(headers, ["반환일자","반환 일자","반환일"]);
        if (idxReturn === -1) headers.push("반환일자");
        for (const row of allRows) while (row.length < headers.length) row.push("");
      }

      const viewRows = allRows.slice(-GRID_LIMIT);

      hot = new Handsontable(container, {
        data: viewRows,
        rowHeaders: true,
        colHeaders: headers,
        height: 560,
        width: "100%",
        stretchH: "all",
        licenseKey: "non-commercial-and-evaluation",
        readOnly: true,
        contextMenu: false,
        manualColumnResize: true,
        manualRowResize: true,
        filters: true,
        dropdownMenu: true,
        cells: function (row, col) {
          const props = {};
          const startGlobal = Math.max(0, allRows.length - GRID_LIMIT);
          const globalIdx = startGlobal + row;
          if (highlightGlobalIdx.has(globalIdx)) {
            props.className = (props.className ? props.className + " " : "") + "hot-row-highlight";
          }
          return props;
        }
      });

      setTimeout(() => { hot.render(); hot.refreshDimensions(); }, 0);
    }

    function refreshGridOnly(){
      if (!hot) return;
      hot.loadData(allRows.slice(-GRID_LIMIT));
      setTimeout(() => { hot.render(); hot.refreshDimensions(); }, 0);
    }

    // ===== 로드 =====
    async function loadFile() {
      const { owner, repo, token, path, branch } = getInputs();
      if (!owner || !repo || !token) {
        showStatus("Owner / Repo / Token을 모두 입력해 주세요.", "error");
        setLoaded(false);
        return;
      }

      saveInputsToLocalStorage({owner, repo, token});
      setBusy(true);
      showStatus("정보를 불러오는 중입니다...", "loading");

      try {
        const apiUrl = buildContentsUrl(owner, repo, path, branch);

        const metaRes = await fetch(apiUrl, {
          headers: { "Authorization": `Bearer ${token}`, "Accept": "application/vnd.github+json" }
        });
        if (!metaRes.ok) {
          const txt = await metaRes.text();
          throw new Error(`메타 조회에 실패했습니다. (${metaRes.status})\n${txt}`);
        }
        const meta = await metaRes.json();
        if (Array.isArray(meta)) throw new Error("경로가 파일이 아니라 폴더로 인식되었습니다.");
        currentSha = meta.sha || "";

        if (!meta.download_url) throw new Error("download_url이 존재하지 않습니다.");
        const fileRes = await fetch(meta.download_url);
        if (!fileRes.ok) {
          const txt = await fileRes.text();
          throw new Error(`다운로드에 실패했습니다. (${fileRes.status})\n${txt}`);
        }

        const buf = await fileRes.arrayBuffer();
        const bytes = new Uint8Array(buf);

        const wb = XLSX.read(bytes, { type: "array" });
        const ws = wb.Sheets[wb.SheetNames[0]];
        const aoa = XLSX.utils.sheet_to_json(ws, { header: 1, defval: "" });

        // 로드 시 하이라이트 초기화
        highlightGlobalIdx = new Set();

        initGrid(aoa);
        enableBulkButton(true);

        // 로드 성공 배지(시간 포함)
        const now = new Date();
        const loadedAtText = formatLoadedAt(now);
        localStorage.setItem("gh_loaded_at", loadedAtText);

        setLoaded(true);
        updateTopBadges(true, loadedAtText);

        showStatus("로드가 완료되었습니다.", "success");

        // 로드 성공 후 그리드로 부드럽게 이동
        document.getElementById("hotContainer")?.scrollIntoView({ behavior:"smooth", block:"start" });
      } catch (e) {
        enableBulkButton(false);
        setLoaded(false);
        showStatus(e.message || String(e), "error");
      } finally {
        setBusy(false);
      }
    }

    // ===== 중복 체크(신규) =====
    function isDuplicateNoInExcel(noVal) {
      const v = norm(noVal);
      if (!v) return false;
      const idxNo = findHeaderIndex(headers, noHeaderCandidates());
      if (idxNo === -1) throw new Error((fileKey === "deceased" ? "봉안번호" : "자연장번호") + " 헤더를 찾을 수 없습니다.");
      for (const row of allRows) {
        if (norm(row[idxNo]) === v) return true;
      }
      return false;
    }
    function isDuplicateNoInNewQueue(noVal) {
      const v = norm(noVal);
      for (const q of newQueue) if (norm(q.no) === v) return true;
      return false;
    }

    // ===== 반환: 기존 행 완전일치 찾기 =====
    function findExactMatchRow(noVal, deceasedVal, applicantVal) {
      const idxNo = findHeaderIndex(headers, ["봉안번호","봉안 번호","봉안no","봉안No","번호","관리번호"]);
      const idxDe = findHeaderIndex(headers, ["사망자명","고인명","고인","사망자"]);
      const idxAp = findHeaderIndex(headers, ["신청자명","신청자","사용자명","계약자명"]);
      const idxReturn = findHeaderIndex(headers, ["반환일자","반환 일자","반환일"]);

      const missing = [];
      if (idxNo === -1) missing.push("봉안번호");
      if (idxDe === -1) missing.push("사망자명");
      if (idxAp === -1) missing.push("신청자명");
      if (idxReturn === -1) missing.push("반환일자");
      if (missing.length) throw new Error("헤더를 찾을 수 없습니다: " + missing.join(", "));

      const noN = norm(noVal), deN = norm(deceasedVal), apN = norm(applicantVal);

      for (let r = 0; r < allRows.length; r++) {
        const row = allRows[r];
        if (norm(row[idxNo]) === noN && norm(row[idxDe]) === deN && norm(row[idxAp]) === apN) {
          const hasReturn = String(row[idxReturn] ?? "").trim() !== "";
          return { found:true, rowIndex:r, idxReturn, hasReturn };
        }
      }
      return { found:false };
    }

    // ===== 업로드 → 대기목록 반영 (반환일자 있으면 반환) =====
    async function importBulkExcel() {
      if (!hot) {
        showLoadHint(true);
        setLoaded(false);
        showStatus("불러온 정보가 없습니다. 먼저 ‘불러오기’를 눌러주세요.", "error");
        return;
      }
      if (isBusy) return;

      const input = document.getElementById("bulkFile");
      if (!input || !input.files || input.files.length === 0) {
        showStatus("업로드할 엑셀 파일을 선택해 주세요.", "error");
        return;
      }

      setBusy(true);
      showStatus("업로드 반영 중입니다...", "loading");

      try {
        const file = input.files[0];
        const buf = await file.arrayBuffer();
        const wb = XLSX.read(new Uint8Array(buf), { type: "array" });

        const ws = wb.Sheets[wb.SheetNames[0]];
        const rows = XLSX.utils.sheet_to_json(ws, { defval: "" });

        if (!rows || rows.length === 0) throw new Error("업로드 엑셀에 데이터가 없습니다.");

        let addedNew = 0, addedRet = 0, skipped = 0;

        // 업로드 로그 초기화(이번 반영 기준)
        importLog = [];

        for (let i = 0; i < rows.length; i++) {
          const r = rows[i];
          const rowNo = i + 2;

          const noRaw = String(getCellByHeader(r, ["봉안번호","봉안 번호","자연장번호","자연장 번호","번호","관리번호"])).trim();
          const deceased = String(getCellByHeader(r, ["사망자명","고인명","고인","사망자"])).trim();
          const applicant = String(getCellByHeader(r, ["신청자명","신청자","사용자명","계약자명"])).trim();

          const inDateRaw = String(getCellByHeader(r, ["안치일자","안치 일자","안치일"])).trim();
          const returnRaw = String(getCellByHeader(r, ["반환일자","반환 일자","반환일"])).trim();

          const isReturn = !!String(returnRaw).trim();
          const kind = isReturn ? "반환" : "신규";

          if (!noRaw || !deceased || !applicant) {
            skipped++;
            addImportLog({ rowNo, kind, no:noRaw, deceased, applicant, reason:"필수값이 누락되었습니다(번호/사망자명/신청자명)." });
            continue;
          }

          if (isReturn) {
            if (fileKey !== "deceased") {
              skipped++;
              addImportLog({ rowNo, kind, no:noRaw, deceased, applicant, reason:"자연장지에서는 반환 처리가 불가합니다." });
              continue;
            }

            const returnDate = normalizeDate(returnRaw);
            if (!returnDate) {
              skipped++;
              addImportLog({ rowNo, kind, no:noRaw, deceased, applicant, reason:"반환일자 형식이 올바르지 않습니다." });
              continue;
            }

            let match;
            try { match = findExactMatchRow(noRaw, deceased, applicant); }
            catch (e) {
              skipped++;
              addImportLog({ rowNo, kind, no:noRaw, deceased, applicant, reason:e.message || "헤더 확인이 필요합니다." });
              continue;
            }

            if (!match.found) {
              skipped++;
              addImportLog({ rowNo, kind, no:noRaw, deceased, applicant, reason:"기존 정보와 일치하는 행을 찾을 수 없습니다(완전일치 필요)." });
              continue;
            }
            if (match.hasReturn) {
              skipped++;
              addImportLog({ rowNo, kind, no:noRaw, deceased, applicant, reason:"이미 반환일자가 등록되어 있습니다." });
              continue;
            }

            const key = norm(noRaw) + "|" + norm(deceased) + "|" + norm(applicant);
            let dup = false;
            for (const q of returnQueue) {
              const k2 = norm(q.no) + "|" + norm(q.deceased) + "|" + norm(q.applicant);
              if (k2 === key) { dup = true; break; }
            }
            if (dup) {
              skipped++;
              addImportLog({ rowNo, kind, no:noRaw, deceased, applicant, reason:"반환 대기목록에 동일 항목이 이미 존재합니다(번호/사망자/신청자)." });
              continue;
            }

            returnQueue.push({ no:noRaw, deceased, applicant, returnDate });
            addedRet++;
            continue;
          }

          // 신규
          if (!inDateRaw) {
            skipped++;
            addImportLog({ rowNo, kind, no:noRaw, deceased, applicant, reason:"안치일자가 누락되었습니다(신규)." });
            continue;
          }
          const inDate = normalizeDate(inDateRaw);
          if (!inDate) {
            skipped++;
            addImportLog({ rowNo, kind, no:noRaw, deceased, applicant, reason:"안치일자 형식이 올바르지 않습니다(신규)." });
            continue;
          }

          try {
            if (isDuplicateNoInExcel(noRaw)) {
              skipped++;
              addImportLog({ rowNo, kind, no:noRaw, deceased, applicant, reason:"엑셀 기존 번호와 중복됩니다." });
              continue;
            }
            if (isDuplicateNoInNewQueue(noRaw)) {
              skipped++;
              addImportLog({ rowNo, kind, no:noRaw, deceased, applicant, reason:"신규 대기목록 번호와 중복됩니다." });
              continue;
            }
          } catch (e) {
            skipped++;
            addImportLog({ rowNo, kind, no:noRaw, deceased, applicant, reason:e.message || "중복 체크에 실패했습니다." });
            continue;
          }

          newQueue.push({ inDate, no:noRaw, deceased, applicant });
          addedNew++;
        }

        renderAllQueues();
        renderImportLog();

        showStatus(`업로드 반영이 완료되었습니다.\n신규 ${addedNew}건 / 반환 ${addedRet}건 / 제외 ${skipped}건`, "success");
      } catch (e) {
        showStatus(e.message || String(e), "error");
      } finally {
        setBusy(false);
      }
    }

    // ===== 대기목록 렌더 =====
    function renderAllQueues() {
      // 신규
      document.getElementById("newCount").textContent = `${newQueue.length}건`;
      const newWrap = document.getElementById("newQueueWrap");
      const newMini = document.getElementById("newMini");

      if (newQueue.length === 0) {
        newWrap.innerHTML = "";
        newMini.textContent = "신규 대기목록이 비어 있습니다.";
      } else {
        const noLabel = (fileKey === "deceased") ? "봉안번호" : "자연장번호";
        let html = `<table class="q"><thead><tr>
          <th style="width:70px;">삭제</th>
          <th>안치일자</th>
          <th>${noLabel}</th>
          <th>사망자명</th>
          <th>신청자명</th>
        </tr></thead><tbody>`;
        newQueue.forEach((q, idx) => {
          html += `<tr>
            <td><button class="btn btn-ghost" style="padding:8px 10px; font-size:14px;" onclick="removeNew(${idx})">삭제</button></td>
            <td>${escapeHtml(q.inDate)}</td>
            <td><b>${escapeHtml(q.no)}</b></td>
            <td>${escapeHtml(q.deceased)}</td>
            <td>${escapeHtml(q.applicant)}</td>
          </tr>`;
        });
        html += `</tbody></table>`;
        newWrap.innerHTML = html;
        newMini.textContent = "";
      }

      // 반환(추모의집만)
      if (fileKey === "deceased") {
        document.getElementById("retCount").textContent = `${returnQueue.length}건`;
        const retWrap = document.getElementById("retQueueWrap");
        const retMini = document.getElementById("retMini");

        if (returnQueue.length === 0) {
          retWrap.innerHTML = "";
          retMini.textContent = "반환 대기목록이 비어 있습니다.";
        } else {
          let html = `<table class="q"><thead><tr>
            <th style="width:70px;">삭제</th>
            <th>봉안번호</th>
            <th>사망자명</th>
            <th>신청자명</th>
            <th>반환일자</th>
          </tr></thead><tbody>`;
          returnQueue.forEach((q, idx) => {
            html += `<tr>
              <td><button class="btn btn-ghost" style="padding:8px 10px; font-size:14px;" onclick="removeReturn(${idx})">삭제</button></td>
              <td><b>${escapeHtml(q.no)}</b></td>
              <td>${escapeHtml(q.deceased)}</td>
              <td>${escapeHtml(q.applicant)}</td>
              <td>${escapeHtml(q.returnDate)}</td>
            </tr>`;
          });
          html += `</tbody></table>`;
          retWrap.innerHTML = html;
          retMini.textContent = "";
        }
      }

      setBusy(isBusy);
    }

    function removeNew(idx){ newQueue.splice(idx, 1); renderAllQueues(); }
    function removeReturn(idx){ returnQueue.splice(idx, 1); renderAllQueues(); }

    function clearNewQueue(){
      newQueue = [];
      renderAllQueues();
      showStatus("신규 대기목록을 비웠습니다.", "success");
    }
    function clearReturnQueue(){
      returnQueue = [];
      renderAllQueues();
      showStatus("반환 대기목록을 비웠습니다.", "success");
    }

    // ===== 저장: GitHub PUT =====
    async function putToGitHub(mergedAoa, message) {
      const { owner, repo, token, path, branch } = getInputs();
      const apiUrl = buildContentsUrl(owner, repo, path, branch);

      const ws = XLSX.utils.aoa_to_sheet(mergedAoa);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, "Sheet1");

      const wbOut = XLSX.write(wb, { bookType: "xlsx", type: "array" });
      const bytes = new Uint8Array(wbOut);
      const contentBase64 = uint8ArrayToBase64(bytes);

      const putBody = { message, content: contentBase64, sha: currentSha, branch };

      const res = await fetch(apiUrl, {
        method: "PUT",
        headers: {
          "Authorization": `Bearer ${token}`,
          "Accept": "application/vnd.github+json",
          "Content-Type": "application/json"
        },
        body: JSON.stringify(putBody)
      });

      if (!res.ok) {
        const txt = await res.text();
        throw new Error(`저장에 실패했습니다. (${res.status})\n${txt}`);
      }

      const resData = await res.json();
      currentSha = resData.content?.sha || currentSha;
    }

    // ===== 저장: 신규 =====
    async function saveNewQueue(){
      if (!hot) { showStatus("불러온 정보가 없습니다. 먼저 ‘불러오기’를 눌러주세요.", "error"); showLoadHint(true); setLoaded(false); return; }
      if (newQueue.length === 0) { showStatus("신규 대기목록이 비어 있습니다.", "error"); return; }

      const { owner, repo, token } = getInputs();
      if (!owner || !repo || !token) { showStatus("Owner / Repo / Token이 누락되었습니다.", "error"); return; }

      setBusy(true);
      showStatus("신규 저장 중입니다...", "loading");

      try {
        const idxInDate = findHeaderIndex(headers, ["안치일자","안치 일자","안치일"]);
        const idxNo = findHeaderIndex(headers, noHeaderCandidates());
        const idxDe = findHeaderIndex(headers, ["사망자명","고인명","고인","사망자"]);
        const idxAp = findHeaderIndex(headers, ["신청자명","신청자","사용자명","계약자명"]);

        const missing = [];
        if (idxInDate === -1) missing.push("안치일자");
        if (idxNo === -1) missing.push(fileKey === "deceased" ? "봉안번호" : "자연장번호");
        if (idxDe === -1) missing.push("사망자명");
        if (idxAp === -1) missing.push("신청자명");
        if (missing.length) throw new Error("헤더를 찾을 수 없습니다: " + missing.join(", "));

        // 저장 직전 중복검사: 엑셀 기존 + 신규대기 내부
        const existingSet = new Set();
        for (const row of allRows) {
          const v = norm(row[idxNo]);
          if (v) existingSet.add(v);
        }
        const batchSet = new Set();

        // 하이라이트 인덱스 준비(추가될 행은 append됨)
        highlightGlobalIdx = new Set();
        const startLen = allRows.length;

        for (let i=0; i<newQueue.length; i++) {
          const q = newQueue[i];
          const vv = norm(q.no);
          if (existingSet.has(vv)) throw new Error(`중복(엑셀 기존): ${q.no}`);
          if (batchSet.has(vv)) throw new Error(`중복(신규대기 내부): ${q.no}`);
          batchSet.add(vv);
          existingSet.add(vv);

          const row = new Array(headers.length).fill("");
          row[idxInDate] = q.inDate;
          row[idxNo] = q.no;
          row[idxDe] = q.deceased;
          row[idxAp] = q.applicant;
          allRows.push(row);

          highlightGlobalIdx.add(startLen + i);
        }

        const merged = [headers, ...allRows];
        await putToGitHub(merged, `Append ${newQueue.length} new rows: ${new Date().toISOString()}`);

        refreshGridOnly();

        newQueue = [];
        renderAllQueues();
        showStatus("신규 저장이 완료되었습니다.", "success");
      } catch (e) {
        showStatus(e.message || String(e), "error");
      } finally {
        setBusy(false);
      }
    }

    // ===== 저장: 반환 =====
    async function saveReturnQueue(){
      if (!hot) { showStatus("불러온 정보가 없습니다. 먼저 ‘불러오기’를 눌러주세요.", "error"); showLoadHint(true); setLoaded(false); return; }
      if (fileKey !== "deceased") { showStatus("반환 저장은 추모의집에서만 가능합니다.", "error"); return; }
      if (returnQueue.length === 0) { showStatus("반환 대기목록이 비어 있습니다.", "error"); return; }

      const { owner, repo, token } = getInputs();
      if (!owner || !repo || !token) { showStatus("Owner / Repo / Token이 누락되었습니다.", "error"); return; }

      setBusy(true);
      showStatus("반환 저장 중입니다...", "loading");

      try {
        const idxReturn = findHeaderIndex(headers, ["반환일자","반환 일자","반환일"]);
        if (idxReturn === -1) throw new Error("반환일자 컬럼을 찾을 수 없습니다.");

        // 반환대기 내부 중복키(3키)
        const batchKey = new Set();
        for (const q of returnQueue) {
          const k = norm(q.no) + "|" + norm(q.deceased) + "|" + norm(q.applicant);
          if (batchKey.has(k)) throw new Error(`반환대기 내부 중복이 있습니다: ${q.no}`);
          batchKey.add(k);
        }

        // 이번 저장 변경분만 하이라이트
        highlightGlobalIdx = new Set();

        // 적용
        for (const q of returnQueue) {
          const match = findExactMatchRow(q.no, q.deceased, q.applicant);
          if (!match.found) throw new Error(`일치 정보가 없습니다: ${q.no} / ${q.deceased} / ${q.applicant}`);
          if (match.hasReturn) throw new Error(`이미 반환이 등록되어 있습니다: ${q.no} / ${q.deceased} / ${q.applicant}`);
          allRows[match.rowIndex][match.idxReturn] = q.returnDate;

          highlightGlobalIdx.add(match.rowIndex);
        }

        const merged = [headers, ...allRows];
        await putToGitHub(merged, `Register ${returnQueue.length} returns: ${new Date().toISOString()}`);

        refreshGridOnly();

        returnQueue = [];
        renderAllQueues();
        showStatus("반환 저장이 완료되었습니다.", "success");
      } catch (e) {
        showStatus(e.message || String(e), "error");
      } finally {
        setBusy(false);
      }
    }
  </script>
</body>
</html>
