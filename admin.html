<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>울산하늘공원 데이터 관리자 (일괄등록 전용)</title>

  <!-- Handsontable -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/handsontable/dist/handsontable.full.min.css" />
  <script src="https://cdn.jsdelivr.net/npm/handsontable/dist/handsontable.full.min.js"></script>

  <!-- XLSX -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <style>
    body{
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;
      background:#f6f2ec; color:#2f2a25;
      padding:20px; margin:0;
      display:flex; flex-direction:column; align-items:center;
    }
    .container{
      background:#fff; padding:20px; border-radius:12px;
      box-shadow:0 4px 20px rgba(0,0,0,0.08);
      width:100%; max-width:1200px;
    }
    h1{ margin:0 0 12px; font-size:22px; color:#3a332e; text-align:center; }

    .row{ display:grid; grid-template-columns:repeat(auto-fit,minmax(240px,1fr)); gap:10px; margin-bottom:12px; }
    .box{
      background:#fafafa; padding:14px; border-radius:10px; border:1px solid #eee;
    }
    .box-title{ font-weight:950; margin-bottom:10px; color:#3a332e; }

    .form-group label{ display:block; font-weight:900; font-size:13px; margin-bottom:4px; color:#555; }
    .form-group input{
      width:100%; padding:9px; border:1px solid #dcdcdc; border-radius:8px; font-size:14px;
      box-sizing:border-box; background:#fff;
    }

    .toolbar{ display:flex; gap:10px; justify-content:flex-end; flex-wrap:wrap; margin-top:10px; }
    .btn{
      padding:10px 16px; border:none; border-radius:8px;
      font-size:14px; font-weight:950; cursor:pointer; transition:0.2s; white-space:nowrap;
    }
    .btn:disabled{ background:#ccc; cursor:not-allowed; }
    .btn-load{ background:#3a332e; color:#fff; }
    .btn-load:hover{ background:#524a42; }
    .btn-add{ background:#1f7aec; color:#fff; }
    .btn-add:hover{ background:#1966c6; }
    .btn-save{ background:#27ae60; color:#fff; }
    .btn-save:hover{ background:#219150; }
    .btn-clear{ background:#888; color:#fff; }
    .btn-clear:hover{ background:#6f6f6f; }

    .seg{
      display:flex; gap:10px; justify-content:center; margin-bottom:12px; flex-wrap:wrap;
    }
    .seg button{
      border:1px solid #dcdcdc; background:#fff; color:#3a332e;
      padding:10px 14px; border-radius:999px; font-weight:950; cursor:pointer;
    }
    .seg button.active{
      background:#3a332e; color:#fff; border-color:#3a332e;
    }

    #hotContainer{
      width:100%; height:560px; overflow:auto;
      border:1px solid #dcdcdc; border-radius:8px; background:#fff;
    }

    .status{
      margin:10px 0 12px; padding:10px; border-radius:8px; font-size:14px;
      text-align:center; display:none; white-space:pre-wrap;
    }
    .status.success{ background:#e0f5f0; color:#1d7c6b; }
    .status.error{ background:#fdeaea; color:#b92b27; }
    .status.loading{ background:#f0f0f0; color:#555; }

    .pill{
      display:inline-block; padding:3px 8px; border-radius:999px;
      font-size:12px; font-weight:900; border:1px solid #e3e3e3; background:#f3f3f3;
    }

    table.q{
      width:100%; border-collapse:collapse; background:#fff;
      border-radius:8px; overflow:hidden; border:1px solid #e6e6e6;
    }
    table.q th, table.q td{
      border-bottom:1px solid #eee; padding:10px; font-size:13px; text-align:left; vertical-align:middle;
    }
    table.q th{ background:#f7f7f7; font-weight:950; color:#333; }
    table.q tr:last-child td{ border-bottom:none; }

    .danger{ color:#b92b27; font-weight:950; }
  </style>
</head>

<body>
  <div class="container">
    <h1>데이터 관리자 (일괄등록 전용)</h1>

    <!-- 대상 선택 -->
    <div class="seg">
      <button id="btnDeceased" class="active" onclick="selectTarget('deceased')">추모의집</button>
      <button id="btnNature" onclick="selectTarget('nature')">자연장지</button>
    </div>

    <!-- GitHub 설정 -->
    <div class="box" style="margin-bottom:12px;">
      <div class="row" style="margin:0;">
        <div class="form-group">
          <label>GitHub Owner</label>
          <input type="text" id="owner" placeholder="예: UL-SkyPark" />
        </div>
        <div class="form-group">
          <label>Repository</label>
          <input type="text" id="repo" placeholder="예: ulsan-skypark-search" />
        </div>
        <div class="form-group">
          <label>Access Token</label>
          <input type="password" id="token" placeholder="ghp_... 또는 fine-grained token" />
        </div>
      </div>

      <div class="toolbar">
        <button id="loadBtn" class="btn btn-load" onclick="loadFile()">정보 불러오기</button>
      </div>
    </div>

    <!-- 일괄등록 -->
    <div class="box" style="margin-bottom:12px;">
      <div class="box-title">일괄등록</div>
      <div class="row" style="margin:0;">
        <div class="form-group">
          <label>업로드 엑셀 선택</label>
          <input type="file" id="bulkFile" accept=".xlsx,.xls" />
        </div>
      </div>
      <div class="toolbar">
        <button class="btn btn-add" id="bulkBtn" onclick="importBulkExcel()" disabled>업로드 반영</button>
      </div>
    </div>

    <!-- 상태 -->
    <div id="statusMsg" class="status"></div>

    <!-- 대기목록: 신규 -->
    <div class="box" style="margin-bottom:12px;">
      <div class="box-title">
        신규 대기목록 <span class="pill" id="newCount">0건</span>
      </div>
      <div class="toolbar" style="justify-content:flex-end; margin-top:0; margin-bottom:10px;">
        <button id="saveNewBtn" class="btn btn-save" onclick="saveNewQueue()" disabled>신규 저장</button>
        <button id="clearNewBtn" class="btn btn-clear" onclick="clearNewQueue()" disabled>신규 비우기</button>
      </div>
      <div id="newQueueWrap"></div>
      <div id="newMini" style="font-size:12px; color:#777;">신규 대기목록이 비어있어.</div>
    </div>

    <!-- 대기목록: 반환(추모의집만) -->
    <div class="box" style="margin-bottom:12px;" id="returnQueueBox">
      <div class="box-title">
        반환 대기목록 <span class="pill" id="retCount">0건</span>
      </div>
      <div class="toolbar" style="justify-content:flex-end; margin-top:0; margin-bottom:10px;">
        <button id="saveReturnBtn" class="btn btn-save" onclick="saveReturnQueue()" disabled>반환 저장</button>
        <button id="clearReturnBtn" class="btn btn-clear" onclick="clearReturnQueue()" disabled>반환 비우기</button>
      </div>
      <div id="retQueueWrap"></div>
      <div id="retMini" style="font-size:12px; color:#777;">반환 대기목록이 비어있어.</div>
    </div>

    <!-- 업로드 제외 로그 -->
    <div class="box" style="margin-bottom:12px;">
      <div class="box-title">업로드 제외 로그 <span class="pill" id="logCount">0건</span></div>
      <div id="logWrap"></div>
      <div id="logMini" style="font-size:12px; color:#777;">제외된 항목이 없어.</div>
    </div>

    <!-- 최근 20건만 표시 -->
    <div id="hotContainer"></div>
  </div>

  <script>
    // ===== 설정 =====
    const BRANCH = "main";
    const FILES = {
      deceased: "data/deceased_data.xlsx",
      nature: "data/nature_data.xlsx"
    };
    const GRID_LIMIT = 20; // 최근 20건

    // ===== 상태 =====
    let hot = null;
    let currentSha = "";
    let headers = [];
    let fileKey = "deceased";
    let isBusy = false;

    // 전체 데이터(헤더 제외 본문 전체) 저장
    let allRows = [];

    // 대기목록
    let newQueue = [];
    let returnQueue = [];

    // 업로드 제외 로그
    let importLog = [];

    window.onload = () => {
      const savedOwner = localStorage.getItem("gh_owner");
      const savedRepo  = localStorage.getItem("gh_repo");
      const savedToken = localStorage.getItem("gh_token");
      const savedTarget = localStorage.getItem("gh_target");

      if (savedOwner) document.getElementById("owner").value = savedOwner;
      if (savedRepo)  document.getElementById("repo").value  = savedRepo;
      if (savedToken) document.getElementById("token").value = savedToken;
      if (savedTarget === "nature") fileKey = "nature";

      selectTarget(fileKey, true);
      renderAllQueues();
      renderImportLog();
      enableBulkButton(false);
    };

    function selectTarget(target, isInit=false) {
      fileKey = target;
      localStorage.setItem("gh_target", fileKey);

      document.getElementById("btnDeceased").classList.toggle("active", fileKey === "deceased");
      document.getElementById("btnNature").classList.toggle("active", fileKey === "nature");

      document.getElementById("returnQueueBox").style.display = (fileKey === "deceased") ? "block" : "none";

      // 초기화
      newQueue = [];
      returnQueue = [];
      importLog = [];
      allRows = [];
      hot = null;
      headers = [];
      currentSha = "";

      document.getElementById("hotContainer").innerHTML = "";
      renderAllQueues();
      renderImportLog();
      enableBulkButton(false);
      setBusy(false);

      if (!isInit) showStatus("대상 변경됨. '정보 불러오기'부터 다시 해줘.", "loading");
    }

    function showStatus(msg, type) {
      const el = document.getElementById("statusMsg");
      el.textContent = msg;
      el.className = "status " + type;
      el.style.display = "block";
      if (type === "success") setTimeout(() => (el.style.display = "none"), 2500);
    }

    function setBusy(b) {
      isBusy = b;

      document.getElementById("loadBtn").disabled = b;

      document.getElementById("bulkBtn").disabled = b || !hot;

      document.getElementById("saveNewBtn").disabled = b || !hot || newQueue.length === 0;
      document.getElementById("clearNewBtn").disabled = b || newQueue.length === 0;

      document.getElementById("saveReturnBtn").disabled = b || !hot || fileKey !== "deceased" || returnQueue.length === 0;
      document.getElementById("clearReturnBtn").disabled = b || fileKey !== "deceased" || returnQueue.length === 0;
    }

    function enableBulkButton(enable) {
      const b = document.getElementById("bulkBtn");
      if (b) b.disabled = !enable;
    }

    function getInputs() {
      const owner = document.getElementById("owner").value.trim();
      const repo  = document.getElementById("repo").value.trim();
      const token = document.getElementById("token").value.trim();
      const path = FILES[fileKey];
      return { owner, repo, token, path, branch: BRANCH };
    }

    function saveInputsToLocalStorage({owner, repo, token}) {
      localStorage.setItem("gh_owner", owner);
      localStorage.setItem("gh_repo", repo);
      localStorage.setItem("gh_token", token);
    }

    function buildContentsUrl(owner, repo, path, branch) {
      return `https://api.github.com/repos/${owner}/${repo}/contents/${encodeURI(path)}?ref=${encodeURIComponent(branch)}`;
    }

    // ===== 유틸 =====
    function norm(s) {
      return String(s ?? "")
        .replace(/\s+/g, "")
        .replace(/[–—]/g, "-")
        .toLowerCase();
    }
    function escapeHtml(s) {
      return String(s ?? "")
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }
    function normalizeDate(input) {
      const raw = String(input ?? "").trim();
      if (!raw) return "";
      const onlyNum = raw.replace(/[^0-9]/g, "");
      if (onlyNum.length === 8) {
        const y = onlyNum.slice(0,4), m = onlyNum.slice(4,6), d = onlyNum.slice(6,8);
        return `${y}-${m}-${d}`;
      }
      const cleaned = raw.replace(/\./g, "-").replace(/\//g, "-");
      const parts = cleaned.split("-").map(p => p.trim()).filter(Boolean);
      if (parts.length >= 3) {
        let [y,m,d] = parts;
        if (y.length === 2) y = "20" + y;
        m = String(parseInt(m,10)).padStart(2,"0");
        d = String(parseInt(d,10)).padStart(2,"0");
        if (!/^\d{4}$/.test(y) || m === "NaN" || d === "NaN") return "";
        return `${y}-${m}-${d}`;
      }
      return "";
    }
    function findHeaderIndex(hs, candidates) {
      const list = hs.map(norm);
      for (const cand of candidates) {
        const idx = list.indexOf(norm(cand));
        if (idx !== -1) return idx;
      }
      return -1;
    }
    function uint8ArrayToBase64(u8) {
      let binary = "";
      const chunkSize = 0x8000;
      for (let i = 0; i < u8.length; i += chunkSize) {
        const chunk = u8.subarray(i, i + chunkSize);
        binary += String.fromCharCode.apply(null, chunk);
      }
      return btoa(binary);
    }
    function getCellByHeader(rowObj, candidates) {
      const keys = Object.keys(rowObj || {});
      const map = new Map(keys.map(k => [norm(k), k]));
      for (const c of candidates) {
        const key = map.get(norm(c));
        if (key !== undefined) return rowObj[key];
      }
      return "";
    }
    function noHeaderCandidates() {
      return (fileKey === "deceased")
        ? ["봉안번호","봉안 번호","봉안no","봉안No","번호","관리번호"]
        : ["자연장번호","자연장 번호","자연장no","자연장No","번호","관리번호"];
    }

    // ===== 로그 =====
    function addImportLog(item){ importLog.push(item); }
    function renderImportLog() {
      document.getElementById("logCount").textContent = `${importLog.length}건`;
      const wrap = document.getElementById("logWrap");
      const mini = document.getElementById("logMini");

      if (importLog.length === 0) {
        wrap.innerHTML = "";
        mini.textContent = "제외된 항목이 없어.";
        return;
      }

      mini.textContent = "업로드에서 제외된 항목과 이유야.";
      let html = `<table class="q"><thead><tr>
        <th style="width:90px;">엑셀행</th>
        <th style="width:80px;">구분</th>
        <th>번호</th>
        <th>사망자명</th>
        <th>신청자명</th>
        <th>제외 사유</th>
      </tr></thead><tbody>`;

      importLog.forEach(l => {
        html += `<tr>
          <td>${escapeHtml(l.rowNo)}</td>
          <td><span class="pill">${escapeHtml(l.kind)}</span></td>
          <td><b>${escapeHtml(l.no || "")}</b></td>
          <td>${escapeHtml(l.deceased || "")}</td>
          <td>${escapeHtml(l.applicant || "")}</td>
          <td class="danger">${escapeHtml(l.reason)}</td>
        </tr>`;
      });

      html += `</tbody></table>`;
      wrap.innerHTML = html;
    }

    // ===== 로드 =====
    async function loadFile() {
      const { owner, repo, token, path, branch } = getInputs();
      if (!owner || !repo || !token) {
        showStatus("Owner / Repo / Token을 입력해줘.", "error");
        return;
      }

      saveInputsToLocalStorage({owner, repo, token});
      setBusy(true);
      showStatus("정보 불러오는 중...", "loading");

      try {
        const apiUrl = buildContentsUrl(owner, repo, path, branch);

        const metaRes = await fetch(apiUrl, {
          headers: { "Authorization": `Bearer ${token}`, "Accept": "application/vnd.github+json" }
        });
        if (!metaRes.ok) {
          const txt = await metaRes.text();
          throw new Error(`메타 조회 실패 (${metaRes.status})\n${txt}`);
        }
        const meta = await metaRes.json();
        if (Array.isArray(meta)) throw new Error("경로가 파일이 아니라 폴더로 인식됐어.");
        currentSha = meta.sha || "";

        if (!meta.download_url) throw new Error("download_url이 없어.");
        const fileRes = await fetch(meta.download_url);
        if (!fileRes.ok) {
          const txt = await fileRes.text();
          throw new Error(`다운로드 실패 (${fileRes.status})\n${txt}`);
        }

        const buf = await fileRes.arrayBuffer();
        const bytes = new Uint8Array(buf);

        const wb = XLSX.read(bytes, { type: "array" });
        const ws = wb.Sheets[wb.SheetNames[0]];
        const aoa = XLSX.utils.sheet_to_json(ws, { header: 1, defval: "" });

        initGrid(aoa);
        enableBulkButton(true);
        showStatus("로드 완료!", "success");
      } catch (e) {
        enableBulkButton(false);
        showStatus(e.message || String(e), "error");
      } finally {
        setBusy(false);
      }
    }

    function initGrid(aoa) {
      const container = document.getElementById("hotContainer");
      container.innerHTML = "";

      headers = (aoa && aoa.length > 0) ? aoa[0].map(h => String(h ?? "").trim()) : [];
      allRows = (aoa && aoa.length > 1) ? aoa.slice(1) : [];

      // 추모의집: 반환일자 컬럼 없으면 생성
      if (fileKey === "deceased") {
        const idxReturn = findHeaderIndex(headers, ["반환일자","반환 일자","반환일"]);
        if (idxReturn === -1) headers.push("반환일자");
        for (const row of allRows) while (row.length < headers.length) row.push("");
      }

      const viewRows = allRows.slice(-GRID_LIMIT);

      hot = new Handsontable(container, {
        data: viewRows,
        rowHeaders: true,
        colHeaders: headers,
        height: 560,
        width: "100%",
        stretchH: "all",
        licenseKey: "non-commercial-and-evaluation",
        readOnly: true,
        contextMenu: false,
        manualColumnResize: true,
        manualRowResize: true,
        filters: true,
        dropdownMenu: true
      });

      setTimeout(() => { hot.render(); hot.refreshDimensions(); }, 0);
    }

    // ===== 중복 체크(신규) =====
    function isDuplicateNoInExcel(noVal) {
      const v = norm(noVal);
      if (!v) return false;
      const idxNo = findHeaderIndex(headers, noHeaderCandidates());
      if (idxNo === -1) throw new Error((fileKey === "deceased" ? "봉안번호" : "자연장번호") + " 헤더를 못 찾았어.");
      for (const row of allRows) {
        if (norm(row[idxNo]) === v) return true;
      }
      return false;
    }
    function isDuplicateNoInNewQueue(noVal) {
      const v = norm(noVal);
      for (const q of newQueue) if (norm(q.no) === v) return true;
      return false;
    }

    // ===== 반환: 기존 행 완전일치 찾기 =====
    function findExactMatchRow(noVal, deceasedVal, applicantVal) {
      const idxNo = findHeaderIndex(headers, ["봉안번호","봉안 번호","봉안no","봉안No","번호","관리번호"]);
      const idxDe = findHeaderIndex(headers, ["사망자명","고인명","고인","사망자"]);
      const idxAp = findHeaderIndex(headers, ["신청자명","신청자","사용자명","계약자명"]);
      const idxReturn = findHeaderIndex(headers, ["반환일자","반환 일자","반환일"]);

      const missing = [];
      if (idxNo === -1) missing.push("봉안번호");
      if (idxDe === -1) missing.push("사망자명");
      if (idxAp === -1) missing.push("신청자명");
      if (idxReturn === -1) missing.push("반환일자");
      if (missing.length) throw new Error("헤더를 못 찾았어: " + missing.join(", "));

      const noN = norm(noVal), deN = norm(deceasedVal), apN = norm(applicantVal);

      for (let r = 0; r < allRows.length; r++) {
        const row = allRows[r];
        if (norm(row[idxNo]) === noN && norm(row[idxDe]) === deN && norm(row[idxAp]) === apN) {
          const hasReturn = String(row[idxReturn] ?? "").trim() !== "";
          return { found:true, rowIndex:r, idxReturn, hasReturn };
        }
      }
      return { found:false };
    }

    // ===== 업로드 → 대기목록 반영 (반환일자 있으면 반환) =====
    async function importBulkExcel() {
      if (!hot) { showStatus("먼저 '정보 불러오기' 해줘.", "error"); return; }
      if (isBusy) return;

      const input = document.getElementById("bulkFile");
      if (!input || !input.files || input.files.length === 0) {
        showStatus("업로드할 엑셀 파일을 선택해줘.", "error");
        return;
      }

      setBusy(true);
      showStatus("업로드 반영 중...", "loading");

      try {
        const file = input.files[0];
        const buf = await file.arrayBuffer();
        const wb = XLSX.read(new Uint8Array(buf), { type: "array" });

        const ws = wb.Sheets[wb.SheetNames[0]];
        const rows = XLSX.utils.sheet_to_json(ws, { defval: "" });

        if (!rows || rows.length === 0) throw new Error("업로드 엑셀에 데이터가 없어.");

        let addedNew = 0, addedRet = 0, skipped = 0;

        for (let i = 0; i < rows.length; i++) {
          const r = rows[i];
          const rowNo = i + 2;

          const noRaw = String(getCellByHeader(r, ["봉안번호","봉안 번호","자연장번호","자연장 번호","번호","관리번호"])).trim();
          const deceased = String(getCellByHeader(r, ["사망자명","고인명","고인","사망자"])).trim();
          const applicant = String(getCellByHeader(r, ["신청자명","신청자","사용자명","계약자명"])).trim();

          const inDateRaw = String(getCellByHeader(r, ["안치일자","안치 일자","안치일"])).trim();
          const returnRaw = String(getCellByHeader(r, ["반환일자","반환 일자","반환일"])).trim();

          const isReturn = !!String(returnRaw).trim();
          const kind = isReturn ? "반환" : "신규";

          if (!noRaw || !deceased || !applicant) {
            skipped++;
            addImportLog({ rowNo, kind, no:noRaw, deceased, applicant, reason:"필수값 누락(번호/사망자명/신청자명)" });
            continue;
          }

          if (isReturn) {
            if (fileKey !== "deceased") {
              skipped++;
              addImportLog({ rowNo, kind, no:noRaw, deceased, applicant, reason:"자연장지에서는 반환 처리 불가" });
              continue;
            }

            const returnDate = normalizeDate(returnRaw);
            if (!returnDate) {
              skipped++;
              addImportLog({ rowNo, kind, no:noRaw, deceased, applicant, reason:"반환일자 형식 오류" });
              continue;
            }

            let match;
            try { match = findExactMatchRow(noRaw, deceased, applicant); }
            catch (e) {
              skipped++;
              addImportLog({ rowNo, kind, no:noRaw, deceased, applicant, reason:e.message || "헤더 확인 필요" });
              continue;
            }

            if (!match.found) {
              skipped++;
              addImportLog({ rowNo, kind, no:noRaw, deceased, applicant, reason:"기존정보 불일치(완전일치 행 없음)" });
              continue;
            }
            if (match.hasReturn) {
              skipped++;
              addImportLog({ rowNo, kind, no:noRaw, deceased, applicant, reason:"이미 반환일자 등록됨" });
              continue;
            }

            const key = norm(noRaw) + "|" + norm(deceased) + "|" + norm(applicant);
            let dup = false;
            for (const q of returnQueue) {
              const k2 = norm(q.no) + "|" + norm(q.deceased) + "|" + norm(q.applicant);
              if (k2 === key) { dup = true; break; }
            }
            if (dup) {
              skipped++;
              addImportLog({ rowNo, kind, no:noRaw, deceased, applicant, reason:"반환대기 중복(같은 3키)" });
              continue;
            }

            returnQueue.push({ no:noRaw, deceased, applicant, returnDate });
            addedRet++;
            continue;
          }

          // 신규
          if (!inDateRaw) {
            skipped++;
            addImportLog({ rowNo, kind, no:noRaw, deceased, applicant, reason:"안치일자 누락(신규)" });
            continue;
          }
          const inDate = normalizeDate(inDateRaw);
          if (!inDate) {
            skipped++;
            addImportLog({ rowNo, kind, no:noRaw, deceased, applicant, reason:"안치일자 형식 오류(신규)" });
            continue;
          }

          try {
            if (isDuplicateNoInExcel(noRaw)) {
              skipped++;
              addImportLog({ rowNo, kind, no:noRaw, deceased, applicant, reason:"중복(엑셀 기존 번호)" });
              continue;
            }
            if (isDuplicateNoInNewQueue(noRaw)) {
              skipped++;
              addImportLog({ rowNo, kind, no:noRaw, deceased, applicant, reason:"중복(신규대기 번호)" });
              continue;
            }
          } catch (e) {
            skipped++;
            addImportLog({ rowNo, kind, no:noRaw, deceased, applicant, reason:e.message || "중복 체크 실패" });
            continue;
          }

          newQueue.push({ inDate, no:noRaw, deceased, applicant });
          addedNew++;
        }

        renderAllQueues();
        renderImportLog();
        showStatus(`업로드 반영 완료!\n신규 ${addedNew}건 / 반환 ${addedRet}건 / 제외 ${skipped}건`, "success");
      } catch (e) {
        showStatus(e.message || String(e), "error");
      } finally {
        setBusy(false);
      }
    }

    // ===== 대기목록 렌더 =====
    function renderAllQueues() {
      // 신규
      document.getElementById("newCount").textContent = `${newQueue.length}건`;
      const newWrap = document.getElementById("newQueueWrap");
      const newMini = document.getElementById("newMini");

      if (newQueue.length === 0) {
        newWrap.innerHTML = "";
        newMini.textContent = "신규 대기목록이 비어있어.";
      } else {
        const noLabel = (fileKey === "deceased") ? "봉안번호" : "자연장번호";
        let html = `<table class="q"><thead><tr>
          <th style="width:60px;">삭제</th>
          <th>안치일자</th>
          <th>${noLabel}</th>
          <th>사망자명</th>
          <th>신청자명</th>
        </tr></thead><tbody>`;
        newQueue.forEach((q, idx) => {
          html += `<tr>
            <td><button class="btn btn-clear" style="padding:6px 10px; font-size:12px;" onclick="removeNew(${idx})">삭제</button></td>
            <td>${escapeHtml(q.inDate)}</td>
            <td><b>${escapeHtml(q.no)}</b></td>
            <td>${escapeHtml(q.deceased)}</td>
            <td>${escapeHtml(q.applicant)}</td>
          </tr>`;
        });
        html += `</tbody></table>`;
        newWrap.innerHTML = html;
        newMini.textContent = "";
      }

      // 반환(추모의집만)
      if (fileKey === "deceased") {
        document.getElementById("retCount").textContent = `${returnQueue.length}건`;
        const retWrap = document.getElementById("retQueueWrap");
        const retMini = document.getElementById("retMini");

        if (returnQueue.length === 0) {
          retWrap.innerHTML = "";
          retMini.textContent = "반환 대기목록이 비어있어.";
        } else {
          let html = `<table class="q"><thead><tr>
            <th style="width:60px;">삭제</th>
            <th>봉안번호</th>
            <th>사망자명</th>
            <th>신청자명</th>
            <th>반환일자</th>
          </tr></thead><tbody>`;
          returnQueue.forEach((q, idx) => {
            html += `<tr>
              <td><button class="btn btn-clear" style="padding:6px 10px; font-size:12px;" onclick="removeReturn(${idx})">삭제</button></td>
              <td><b>${escapeHtml(q.no)}</b></td>
              <td>${escapeHtml(q.deceased)}</td>
              <td>${escapeHtml(q.applicant)}</td>
              <td>${escapeHtml(q.returnDate)}</td>
            </tr>`;
          });
          html += `</tbody></table>`;
          retWrap.innerHTML = html;
          retMini.textContent = "";
        }
      }

      setBusy(isBusy);
    }

    function removeNew(idx){ newQueue.splice(idx, 1); renderAllQueues(); }
    function removeReturn(idx){ returnQueue.splice(idx, 1); renderAllQueues(); }

    function clearNewQueue(){
      newQueue = [];
      renderAllQueues();
      showStatus("신규 대기목록을 비웠어.", "success");
    }
    function clearReturnQueue(){
      returnQueue = [];
      renderAllQueues();
      showStatus("반환 대기목록을 비웠어.", "success");
    }

    // ===== 저장 =====
    async function putToGitHub(mergedAoa, message) {
      const { owner, repo, token, path, branch } = getInputs();
      const apiUrl = buildContentsUrl(owner, repo, path, branch);

      const ws = XLSX.utils.aoa_to_sheet(mergedAoa);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, "Sheet1");

      const wbOut = XLSX.write(wb, { bookType: "xlsx", type: "array" });
      const bytes = new Uint8Array(wbOut);
      const contentBase64 = uint8ArrayToBase64(bytes);

      const putBody = { message, content: contentBase64, sha: currentSha, branch };

      const res = await fetch(apiUrl, {
        method: "PUT",
        headers: {
          "Authorization": `Bearer ${token}`,
          "Accept": "application/vnd.github+json",
          "Content-Type": "application/json"
        },
        body: JSON.stringify(putBody)
      });

      if (!res.ok) {
        const txt = await res.text();
        throw new Error(`저장 실패 (${res.status})\n${txt}`);
      }

      const resData = await res.json();
      currentSha = resData.content?.sha || currentSha;
    }

    async function saveNewQueue(){
      if (!hot) { showStatus("먼저 '정보 불러오기' 해줘.", "error"); return; }
      if (newQueue.length === 0) { showStatus("신규 대기목록이 비어있어.", "error"); return; }

      const { owner, repo, token } = getInputs();
      if (!owner || !repo || !token) { showStatus("Owner / Repo / Token이 누락됐어.", "error"); return; }

      setBusy(true);
      showStatus("신규 저장 중...", "loading");

      try {
        const idxInDate = findHeaderIndex(headers, ["안치일자","안치 일자","안치일"]);
        const idxNo = findHeaderIndex(headers, noHeaderCandidates());
        const idxDe = findHeaderIndex(headers, ["사망자명","고인명","고인","사망자"]);
        const idxAp = findHeaderIndex(headers, ["신청자명","신청자","사용자명","계약자명"]);

        const missing = [];
        if (idxInDate === -1) missing.push("안치일자");
        if (idxNo === -1) missing.push(fileKey === "deceased" ? "봉안번호" : "자연장번호");
        if (idxDe === -1) missing.push("사망자명");
        if (idxAp === -1) missing.push("신청자명");
        if (missing.length) throw new Error("헤더를 못 찾았어: " + missing.join(", "));

        // 저장 직전 중복검사: 엑셀 기존 + 신규대기 내부
        const existingSet = new Set();
        for (const row of allRows) {
          const v = norm(row[idxNo]);
          if (v) existingSet.add(v);
        }
        const batchSet = new Set();

        for (const q of newQueue) {
          const vv = norm(q.no);
          if (existingSet.has(vv)) throw new Error(`중복(엑셀 기존): ${q.no}`);
          if (batchSet.has(vv)) throw new Error(`중복(신규대기 내부): ${q.no}`);
          batchSet.add(vv);
          existingSet.add(vv);

          const row = new Array(headers.length).fill("");
          row[idxInDate] = q.inDate;
          row[idxNo] = q.no;
          row[idxDe] = q.deceased;
          row[idxAp] = q.applicant;
          allRows.push(row);
        }

        const merged = [headers, ...allRows];
        await putToGitHub(merged, `Append ${newQueue.length} new rows: ${new Date().toISOString()}`);

        // 그리드: 최근 20건만
        hot.loadData(allRows.slice(-GRID_LIMIT));
        setTimeout(() => { hot.render(); hot.refreshDimensions(); }, 0);

        newQueue = [];
        renderAllQueues();
        showStatus("신규 저장 완료!", "success");
      } catch (e) {
        showStatus(e.message || String(e), "error");
      } finally {
        setBusy(false);
      }
    }

    async function saveReturnQueue(){
      if (!hot) { showStatus("먼저 '정보 불러오기' 해줘.", "error"); return; }
      if (fileKey !== "deceased") { showStatus("반환 저장은 추모의집에서만 가능해.", "error"); return; }
      if (returnQueue.length === 0) { showStatus("반환 대기목록이 비어있어.", "error"); return; }

      const { owner, repo, token } = getInputs();
      if (!owner || !repo || !token) { showStatus("Owner / Repo / Token이 누락됐어.", "error"); return; }

      setBusy(true);
      showStatus("반환 저장 중...", "loading");

      try {
        const idxReturn = findHeaderIndex(headers, ["반환일자","반환 일자","반환일"]);
        if (idxReturn === -1) throw new Error("반환일자 컬럼을 못 찾았어.");

        // 반환대기 내부 중복키(3키)
        const batchKey = new Set();
        for (const q of returnQueue) {
          const k = norm(q.no) + "|" + norm(q.deceased) + "|" + norm(q.applicant);
          if (batchKey.has(k)) throw new Error(`반환대기 내부 중복: ${q.no}`);
          batchKey.add(k);
        }

        // 적용
        for (const q of returnQueue) {
          const match = findExactMatchRow(q.no, q.deceased, q.applicant);
          if (!match.found) throw new Error(`일치 정보 없음: ${q.no} / ${q.deceased} / ${q.applicant}`);
          if (match.hasReturn) throw new Error(`이미 반환 등록됨: ${q.no} / ${q.deceased} / ${q.applicant}`);
          allRows[match.rowIndex][match.idxReturn] = q.returnDate;
        }

        const merged = [headers, ...allRows];
        await putToGitHub(merged, `Register ${returnQueue.length} returns: ${new Date().toISOString()}`);

        hot.loadData(allRows.slice(-GRID_LIMIT));
        setTimeout(() => { hot.render(); hot.refreshDimensions(); }, 0);

        returnQueue = [];
        renderAllQueues();
        showStatus("반환 저장 완료!", "success");
      } catch (e) {
        showStatus(e.message || String(e), "error");
      } finally {
        setBusy(false);
      }
    }
  </script>
</body>
</html>
