<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover"/>
  <title>추모의집 봉안 현황</title>
  <link rel="icon" type="image/x-icon" href="./images/symbol.png">
  <link rel="apple-touch-icon" href="./images/symbol.png">

  <style>
    :root{
      --page-bg: #f6f2ec;
      --panel-bg: #fbf8f4;
      --panel-border: #e3dbd1;
      --text: #2f2a25;
      --muted: #6c5f56;

      --cell-w: 58px;
      --cell-h: 48px;
      --cell-border: #d0c6bb;

      --bg-empty: #f3f1ed;
      --bg-used:  #e9e3dc;

      --next-red: #b43a3a;
      --next-red-strong: #9b2525;

      --plus-color: #b8b8bf;
    }

    body{
      margin:16px;
      background: var(--page-bg);
      color: var(--text);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans KR", Arial, sans-serif;
    }

    h1{
      margin: 0 0 10px;
      font-size: 22px;
      font-weight: 950;
      letter-spacing: .2px;
      line-height: 1.15;
    }

    .panel{
      padding:12px;
      border:1px solid var(--panel-border);
      border-radius:14px;
      background: var(--panel-bg);
      box-shadow: 0 1px 0 rgba(0,0,0,0.03);
      margin-bottom: 10px;
    }
    .panel.sticky{
      position: sticky;
      top: 0;
      z-index: 50;
      backdrop-filter: blur(6px);
      padding-top: calc(10px + env(safe-area-inset-top, 0px));
      padding-bottom: 10px;
    }

    .panel-top{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }

    /* ✅ 다음 봉안 예정(부부단만) - 폭 줄임 */
    .next-wrap{
      display:none;
      flex: 0 1 520px;
      max-width: 560px;

      padding:8px 10px;
      border:1px solid rgba(180,58,58,0.22);
      background: rgba(180,58,58,0.06);
      border-radius: 14px;
      user-select:none;

      display:flex;
      flex-direction:column;
      gap:6px;
      min-width: 320px;
    }
    .next-head{
      font-weight: 950;
      font-size: 16px;
      letter-spacing: .15px;
      color: rgba(155,37,37,0.88);
      display:flex;
      align-items:center;
      gap:8px;
      white-space: nowrap;
      line-height: 1;
    }
    .next-head::before{
      content:"";
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: var(--next-red);
      opacity: .9;
      flex: 0 0 auto;
    }

    .next-rows{
      display:grid;
      grid-template-columns: 1fr;
      gap:8px;
    }

    .next-line{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:nowrap;

      padding:7px 9px;
      border-radius: 12px;
      background: rgba(255,255,255,0.62);
      border:1px solid rgba(180,58,58,0.14);

      min-height: 40px;
      overflow:hidden;
    }
    .next-label{
      font-weight: 950;
      color: var(--next-red-strong);
      white-space: nowrap;
      flex: 0 0 auto;
      font-size: 20px;
    }
    .next-text{
      font-weight: 950;
      font-size: 20px;
      color: #6b1f1f;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-variant-numeric: tabular-nums;
      letter-spacing: .2px;
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
      flex: 1 1 auto;
    }
    .next-move-btn{
      border:1px solid rgba(180,58,58,0.28);
      background: rgba(255,255,255,0.84);
      color: var(--next-red-strong);
      border-radius: 999px;
      padding:9px 10px;
      cursor:pointer;
      font-weight: 950;
      white-space: nowrap;
      min-height: 34px;
      flex: 0 0 auto;
      touch-action: manipulation;
    }
    .next-move-btn:hover{ background: rgba(255,255,255,0.98); }
    .next-move-btn:disabled{ opacity: .45; cursor: not-allowed; }

    /* ✅ 안내문 */
    .next-note{
      margin-top: 2px;
      padding: 8px 10px;
      border-radius: 12px;
      background: rgba(255,255,255,0.55);
      border: 1px solid rgba(180,58,58,0.10);
      font-size: 12px;
      color: #6c5f56;
      line-height: 1.35;
    }
    .next-note b{ color: rgba(155,37,37,0.88); }

    .search{
      display:flex;
      gap:6px;
      align-items:center;
      margin-left:auto;
      flex-wrap:wrap;
    }
    .search input{
      width: 340px;
      max-width: 70vw;
      padding: 10px 10px;
      border-radius: 12px;
      border:1px solid var(--panel-border);
      background:#fff;
      font-size: 16px;
      color: var(--text);
      outline: none;
    }
    .search input::placeholder{ color:#9a8f86; }

    button{
      border: 1px solid var(--panel-border);
      background: #fff;
      padding: 10px 12px;
      border-radius: 12px;
      cursor:pointer;
      color: var(--text);
      font-size: 15px;
      white-space: nowrap;
      min-height: 40px;
      touch-action: manipulation;
    }
    button:hover{ background:#f4f0eb; }

    .tabs{
      display:grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap:8px;
      margin-top: 10px;
    }
    .tab-btn{
      width:100%;
      padding: 10px 10px;
      border-radius: 999px;
      border:1px solid var(--panel-border);
      background:#fff;
      cursor:pointer;
      font-weight: 950;
      color:#3a332e;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:8px;
      text-align:center;
      min-height: 42px;
    }
    .tab-btn.active{
      background:#f1ede8;
      border-color:#d8cfc6;
      box-shadow: 0 0 0 2px rgba(0,0,0,0.03) inset;
    }

    .room-btns{
      display:flex;
      gap:6px;
      flex-wrap:wrap;
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid rgba(0,0,0,0.06);
    }

    .room-btn{
      padding: 8px 12px;
      border-radius: 12px;
      border: 1px solid var(--panel-border);
      background: #fff;
      cursor: pointer;
      font-weight: 950;
      color: #3a332e;
      min-height: 40px;
      transition: all 0.2s ease;
    }
    .room-btn:hover { background: #f4f0eb; }
    .room-btn.active{
      background: #e3ddd3 !important;
      border-color: #9b8670 !important;
      box-shadow: 0 0 0 2px rgba(155, 134, 112, 0.45);
      color: #2b241e !important;
    }

    .legend{
      display:flex; flex-wrap:wrap; gap:14px; align-items:center;
      margin: 8px 0 10px;
      padding: 12px;
      border:1px solid var(--panel-border);
      border-radius:14px;
      background: var(--panel-bg);
    }
    .legend-item{ display:inline-flex; align-items:center; gap:8px; font-size: 13px; color: var(--text); }

    .niche-plus{
      font-size: 18px;
      line-height: 1;
      font-weight: 700;
      color: var(--plus-color);
    }

    .msg{
      margin: 8px 0 10px;
      font-size: 12px;
      color: var(--muted);
      display:none;
    }
    .msg.error{ color:#b00020; }

    /* 검색 결과 드롭다운 */
    .search-results{
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      margin-top: 4px;
      background: #fff;
      border: 1px solid var(--panel-border);
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      max-height: 320px;
      overflow-y: auto;
      z-index: 100;
      display: none;
    }
    .search-results.show{ display: block; }
    .search-result-item{
      padding: 10px 12px;
      cursor: pointer;
      border-bottom: 1px solid #f0f0f0;
      transition: background 0.15s;
    }
    .search-result-item:hover{ background: #f9f6f2; }
    .search-result-item:last-child{ border-bottom: none; }
    .search-result-name{
      font-weight: 900;
      font-size: 15px;
      color: #2f2a25;
      margin-bottom: 4px;
    }
    .search-result-detail{
      font-size: 13px;
      color: #6c5f56;
      font-family: ui-monospace, monospace;
    }

    .scroll-x{
      overflow-x:auto;
      overflow-y: visible;
      padding-top: 12px;
      padding-bottom: 10px;
      position: relative;
      -webkit-overflow-scrolling: touch;
      scroll-behavior: smooth;
    }
    #room{ padding-top: 4px; }
    .room{ display:flex; flex-direction:column; }

    .row{
      display:flex;
      gap:0;
      align-items:stretch;
      position: relative;
    }

    .dan-label{
      width: 58px;
      flex: 0 0 auto;
      position: sticky;
      left: 0;
      z-index: 9999;
      background: var(--page-bg);
      border-right: 1px solid rgba(0,0,0,0.06);
      display:flex;
      align-items:center;
      justify-content:flex-end;
      padding: 0 8px 0 0;
      font-weight: 950;
      color: #3b352f;
      font-size: 13px;
      box-shadow: 6px 0 10px rgba(0,0,0,0.03);
      box-sizing: border-box;
      min-height: calc(var(--cell-h) + 6px);
    }

    .grid{
      display:grid;
      column-gap: 8px;
      row-gap: 5px;
      padding: 1px 0;
    }

    .niche{
      width: var(--cell-w);
      height: var(--cell-h);
      border: 2px solid var(--cell-border);
      border-radius: 11px;
      box-sizing: border-box;
      display:flex;
      flex-direction:column;
      justify-content:space-between;
      overflow:hidden;
      user-select:none;
      position: relative;
      scroll-margin-top: 180px;
    }

    .empty{ background: var(--bg-empty); cursor: default; }
    .used{ background: var(--bg-used); cursor: pointer; }
    .used:hover { outline: 2px solid rgba(0,0,0,0.09); outline-offset: 0px; }
    .empty .niche-top{ justify-content: center; }

    .blank{
      background: transparent;
      border-color: transparent;
    }
    .blank .niche-top,
    .blank .niche-no{ display:none; }

    .niche-top{
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 5px 5px 0 5px;
      min-height: 24px;
    }

    .niche-no{
      flex: 0 0 auto;
      font-size: 12px;
      line-height: 14px;
      padding: 3px 5px 4px;
      text-align:center;
      border-top: 1px solid rgba(0,0,0,0.10);
      background: rgba(255,255,255,0.64);
      color:#2b2520;
      letter-spacing: 0.2px;
      font-weight: 900;
      font-variant-numeric: tabular-nums;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    .next-slot{
      outline: 3px solid var(--next-red);
      outline-offset: -3px;
    }

    @keyframes flashRed {
      0%   { box-shadow: 0 0 0 0 rgba(180,58,58,0.00); outline: 0px solid rgba(180,58,58,0.00); transform: scale(1); }
      20%  { box-shadow: 0 0 0 6px rgba(180,58,58,0.20); outline: 4px solid rgba(180,58,58,0.95); transform: scale(1.02); }
      55%  { box-shadow: 0 0 0 10px rgba(180,58,58,0.14); outline: 4px solid rgba(180,58,58,0.90); transform: scale(1.02); }
      100% { box-shadow: 0 0 0 0 rgba(180,58,58,0.00); outline: 0px solid rgba(180,58,58,0.00); transform: scale(1); }
    }
    .flash { animation: flashRed 1.15s ease-in-out 0s 2; }

    .modal-backdrop{
      position:fixed; inset:0;
      background: rgba(0,0,0,0.45);
      display:none;
      align-items:center;
      justify-content:center;
      padding:16px;
      z-index: 9999;
    }
    .modal{
      width:min(320px, 88vw);
      background:#fff;
      border-radius:16px;
      border:1px solid var(--panel-border);
      box-shadow: 0 18px 40px rgba(0,0,0,0.25);
      overflow:hidden;
    }
    .modal-header{
      padding:14px 14px;
      border-bottom:1px solid #eee;
      background: #faf7f2;
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
    }
    .modal-title{ font-weight:900; font-size:20px; letter-spacing:0.2px; }
    .modal-close{
      border:1px solid var(--panel-border);
      background:#fff;
      border-radius:12px;
      padding:8px 10px;
      cursor:pointer;
      font-size:14px;
    }
    .modal-body{
      padding:14px;
      font-size:18px;
      color:#1f1b17;
      max-height: min(420px, 72vh);
      overflow:auto;
    }
    .kv{
      display:grid;
      grid-template-columns: 80px 1fr;
      gap:12px 10px;
      align-items:start;
    }
    .k{ color: var(--muted); font-weight:900; font-size:14px; padding-top:2px; }
    .v{ font-weight:900; font-size:17px; white-space: pre-wrap; word-break: break-word; line-height:1.5; }
    .list { margin:0; padding-left: 18px; }
    .list li { margin: 6px 0; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-variant-numeric: tabular-nums; }

    @media (max-width: 520px){
      body{ margin:10px; }
      h1{ font-size: 20px; margin-bottom: 8px; }
      .panel{ padding:10px; }
      .tabs{ grid-template-columns: repeat(2, minmax(0, 1fr)); }
      .search input{ width: 260px; max-width: 68vw; }
      :root{ --cell-w: 54px; --cell-h: 46px; }
      .next-wrap{ flex-basis: 420px; max-width: 460px; }
    }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
</head>

<body>
  <h1>추모의집 봉안 현황</h1>

  <div class="panel sticky" id="topPanel">
    <div class="panel-top">
      <!-- ✅ 다음 봉안 예정: 부부단만 -->
      <div id="nextWrap" class="next-wrap" aria-label="부부단 다음 봉안 예정">
        <div class="next-head">부부단 다음 봉안 예정</div>

        <div class="next-rows">
          <div class="next-line">
            <span class="next-label">부부단:</span>
            <span class="next-text" id="nextCoupleText">—</span>
            <button id="nextCoupleMoveBtn" class="next-move-btn" type="button">이동</button>
          </div>
        </div>

        <!-- ✅ 안내문 -->
        <div class="next-note">
          <div>• 본 화면은 <b>매일 18시 기준</b>으로 업데이트됩니다.</div>
          <div>• 실시간 현황 확인은 <b>052-255-3800</b>으로 전화 확인 바랍니다.</div>
        </div>
      </div>

      <div class="search" style="position:relative;">
        <input id="searchInput" type="text" placeholder="안치번호(2~5자리) 또는 고인명을 입력해주세요." autocomplete="off" />
        <div id="searchResults" class="search-results"></div>
        <button id="searchBtn" type="button">검색</button>
        <button id="reloadBtn" type="button">새로고침</button>
      </div>
    </div>

    <div id="tabBar" class="tabs"></div>
    <div id="roomBtns" class="room-btns"></div>
  </div>

  <div class="legend" id="legend"></div>
  <div id="msg" class="msg"></div>

  <div class="scroll-x" id="scrollX">
    <div id="room" class="room"></div>
  </div>

  <div id="modalBackdrop" class="modal-backdrop">
    <div class="modal" role="dialog" aria-modal="true">
      <div class="modal-header">
        <div class="modal-title" id="modalTitle">상세</div>
        <button class="modal-close" id="modalCloseBtn">닫기</button>
      </div>
      <div class="modal-body" id="modalBody"></div>
    </div>
  </div>

<script>
  const EXCEL_URL = "./data/deceased_data.xlsx";

  const STARTS = {
    "01실": 1,    "02실": 217,  "03실": 433,  "04실": 649,  "05실": 865,
    "06실": 1081, "07실": 1279, "08실": 1477, "09실": 1693,

    "10실": 2062,  "11실": 2449,  "12실": 2836,  "13실": 3223,  "14실": 3610,
    "15실": 3997,  "16실": 4384,  "17실": 4771,  "18실": 5158,  "19실": 5545,
    "20실": 5932,  "21실": 6319,  "22실": 6706,  "23실": 7093,  "24실": 7480,
    "25실": 7867,  "26실": 8254,  "27실": 8641,  "28실": 9028,  "29실": 9415,
    "30실": 9802,  "31실": 10189, "32실": 10576, "33실": 10963, "34실": 11350,
    "35실": 11737, "36실": 12394, "37실": 12642, "38실": 12930, "39실": 13202,
    "40실": 13474, "41실": 13762, "42실": 14034, "43실": 14306, "44실": 14594,
    "45실": 14866, "46실": 15138, "47실": 15410, "48실": 15570, "49실": 15954,
    "50실": 16338, "51실": 16722, "52실": 17066, "53실": 17426, "54실": 17786,
    "55실": 18146, "56실": 18506, "57실": 18866, "58실": 19570, "59실": 19890,
    "60실": 20394, "61실": 21078, "62실": 21726
  };
  const END_OVERRIDE = { "62실": 22193 };

  const $ = (id) => document.getElementById(id);
  function pad5(n){ return String(n).padStart(5,"0"); }
  function escapeHtml(s){
    return String(s ?? "")
      .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
      .replaceAll('"',"&quot;").replaceAll("'","&#039;");
  }
  function setMsg(text, kind="info"){
    const el = $("msg");
    if (!text){
      el.textContent = "";
      el.style.display = "none";
      el.classList.remove("error");
      return;
    }
    el.textContent = text;
    el.style.display = "block";
    el.classList.toggle("error", kind === "error");
  }
  function roomStr(n){ return String(n).padStart(2,"0") + "실"; }
  function roomsRange(a,b){ const out=[]; for(let i=a;i<=b;i++) out.push(roomStr(i)); return out; }

  const itemsByStart = Object.entries(STARTS)
    .map(([room, start]) => ({ room, start, roomNum: parseInt(room.replace("실",""),10) }))
    .sort((a,b)=>a.start-b.start);

  const ROOM_CFG = {};
  const tmp = [];
  for (let i=0; i<itemsByStart.length; i++){
    const cur = itemsByStart[i];
    const next = itemsByStart[i+1];
    let end = next ? (next.start - 1) : (END_OVERRIDE[cur.room] ?? (cur.start + 215));
    const count = end - cur.start + 1;

    const div8 = (count % 8 === 0);
    const div9 = (count % 9 === 0);

    let dans = null;
    if (cur.roomNum <= 9) dans = 9;
    else if (div9 && !div8) dans = 9;
    else if (div8 && !div9) dans = 8;
    else if (div8 && div9) dans = null;

    tmp.push({ ...cur, end, count, dans });
  }
  function nearestFixedDans(idx, dir){
    for (let j = idx + dir; j >= 0 && j < tmp.length; j += dir){
      if (tmp[j].dans) return tmp[j].dans;
    }
    return null;
  }
  for (let i=0; i<tmp.length; i++){
    if (!tmp[i].dans){
      const prev = nearestFixedDans(i, -1);
      const next = nearestFixedDans(i, +1);
      tmp[i].dans = (prev && next && prev === next) ? prev : (prev || next || 9);
    }
    const cols = Math.ceil(tmp[i].count / tmp[i].dans);

    ROOM_CFG[tmp[i].room] = {
      room: tmp[i].room,
      roomNum: tmp[i].roomNum,
      start: tmp[i].start,
      end: tmp[i].end,
      count: tmp[i].count,
      dans: tmp[i].dans,
      cols
    };
  }
  const ROOM_LIST = Object.values(ROOM_CFG).sort((a,b)=>a.start-b.start);

  const COUPLE_ROOMS = roomsRange(1,9);
  const PERSONAL1_ROOMS = [...roomsRange(10,18), roomStr(61), roomStr(62)];
  const PERSONAL2A_ROOMS = roomsRange(19,39);
  const PERSONAL2B_ROOMS = roomsRange(40,60);

  const TAB_DEFS = [
    { id:"couple", label:"부부단", rooms: COUPLE_ROOMS },
    { id:"p1", label:"개인단 1층", rooms: PERSONAL1_ROOMS },
    { id:"p2a", label:"개인단 2층(19~39)", rooms: PERSONAL2A_ROOMS },
    { id:"p2b", label:"개인단 2층(40~60)", rooms: PERSONAL2B_ROOMS }
  ];
  const TAB_ROOM_SETS = Object.fromEntries(TAB_DEFS.map(t => [t.id, new Set(t.rooms)]));

  function tabForRoom(room){
    const n = ROOM_CFG[room]?.roomNum ?? 0;
    if (n <= 9) return "couple";
    if (TAB_ROOM_SETS.p1.has(room)) return "p1";
    if (TAB_ROOM_SETS.p2a.has(room)) return "p2a";
    if (TAB_ROOM_SETS.p2b.has(room)) return "p2b";
    return "p1";
  }

  // infoByRoom[room][no5] = {
  //   status:"used"|"empty",
  //   returned:boolean,          // 내부 판단용 (표시 없음)
  //   burialNo:string,
  //   deceasedNames:[],
  //   applicantNames:[],
  //   burialDatesRaw:[],
  //   _effectiveDateMs:number
  // }
  const infoByRoom = {};
  for (const room of Object.keys(ROOM_CFG)) infoByRoom[room] = {};

  let activeTabId = "couple";
  let currentRoom = "01실";
  let nextCouple = null;

  function buildLegend(){
    const showNext = (activeTabId === "couple");
    $("legend").innerHTML = `
      <span class="legend-item">
        <div class="niche-plus" style="font-size:16px; width:20px; text-align:center;">+</div>
        <b>사용가능</b>
      </span>
      <span class="legend-item">
        <span style="display:inline-flex;align-items:center;justify-content:center;width:20px;height:20px;border-radius:999px;background:rgba(60,55,50,0.18);"></span>
        <b>사용중</b>
      </span>
      ${
        showNext
          ? `<span class="legend-item">
               <span style="display:inline-flex;align-items:center;justify-content:center;width:20px;height:20px;border:2px solid var(--next-red);border-radius:8px;"></span>
               <b>다음자리</b>
             </span>`
          : ``
      }
    `;
  }

  function renderTabs(){
    const bar = $("tabBar");
    bar.innerHTML = "";
    for (const t of TAB_DEFS){
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "tab-btn" + (t.id === activeTabId ? " active" : "");
      btn.textContent = t.label;
      btn.addEventListener("click", () => setTab(t.id));
      bar.appendChild(btn);
    }
  }

  function roomHasAnyUsed(room){
    const map = infoByRoom[room] || {};
    for (const rec of Object.values(map)){
      if (rec && rec.status === "used") return true; // 반환 자리도 status used
    }
    return false;
  }
  function shouldHideRoomButton(room){
    if (activeTabId === "p1" || activeTabId === "p2a" || activeTabId === "p2b"){
      return roomHasAnyUsed(room);
    }
    return false;
  }

  function renderRoomButtons() {
    const wrap = $("roomBtns");
    wrap.innerHTML = "";

    const tab = TAB_DEFS.find(x => x.id === activeTabId);
    const rooms = (tab?.rooms || [])
      .filter(r => ROOM_CFG[r])
      .filter(r => !shouldHideRoomButton(r)); // ✅ 개인단 사용중 실 숨김

    for (const room of rooms) {
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "room-btn" + (room === currentRoom ? " active" : "");
      btn.textContent = room;
      btn.addEventListener("click", () => setRoom(room, true));
      wrap.appendChild(btn);
    }
  }

  function setTab(tabId){
    if (!TAB_DEFS.some(t => t.id === tabId)) return;
    activeTabId = tabId;

    buildLegend();

    const tab = TAB_DEFS.find(t => t.id === activeTabId);
    const rooms = (tab?.rooms || []).filter(r => ROOM_CFG[r]).filter(r => !shouldHideRoomButton(r));

    if (!rooms.includes(currentRoom)){
      const first = rooms[0];
      if (first) { setRoom(first, true, { skipTabSync:true }); return; }
    }

    renderTabs();
    renderRoomButtons();
    renderRoom(true);
    saveState();
  }

  function setRoom(room, scrollNext, opts = {}){
    if (!ROOM_CFG[room]) return;

    if (!opts.skipTabSync){
      const needTab = tabForRoom(room);
      if (needTab !== activeTabId) activeTabId = needTab;
    }

    currentRoom = room;

    buildLegend();
    renderTabs();
    renderRoomButtons();
    renderRoom(!!scrollNext);
    saveState();
  }

  function saveState(){
    try{
      localStorage.setItem("memorial_ui_state", JSON.stringify({ tab: activeTabId, room: currentRoom }));
    }catch(e){}
  }
  function restoreState(){
    try{
      const raw = localStorage.getItem("memorial_ui_state");
      if (!raw) return;
      const s = JSON.parse(raw);
      if (s?.tab && TAB_DEFS.some(t=>t.id===s.tab)) activeTabId = s.tab;
      if (s?.room && ROOM_CFG[s.room]) currentRoom = s.room;
    }catch(e){}
  }

  function danOfNo(cfg, noStr){
    const n = parseInt(noStr, 10);
    if (!Number.isFinite(n)) return null;
    if (n < cfg.start || n > cfg.end) return null;
    const idx = n - cfg.start;
    const r = idx % cfg.dans;
    return cfg.dans - r;
  }

  // ✅ 표시용 아이콘/구분 제거: 사용중은 중립 표시로 통일
  function iconHtml(used){
    if (used){
      return `<div style="width:20px;height:20px;border-radius:999px;background:rgba(60,55,50,0.18);"></div>`;
    }
    return `<div class="niche-plus">+</div>`;
  }

  function findNextAvailableNo(cfg){
    for (let n = cfg.start; n <= cfg.end; n++){
      const noStr = pad5(n);
      const rec = infoByRoom[cfg.room][noStr];
      // ✅ 반환 여부와 관계 없이 status used면 사용중 처리
      if (rec?.status === "used") continue;
      return noStr;
    }
    return null;
  }

  function scrollNextSlotIntoCenter(){
    const el = document.querySelector(`.niche.next-slot[data-room="${currentRoom}"]`);
    if (!el) return;
    el.scrollIntoView({ behavior:"smooth", block:"center", inline:"center" });
  }

  function isCoupleRoom(room){ return (ROOM_CFG[room]?.roomNum ?? 99) <= 9; }

  function renderRoom(autoScrollNext){
    const cfg = ROOM_CFG[currentRoom];
    if (!cfg) return;

    setMsg("");

    const host = $("room");
    host.innerHTML = "";

    const nextNo = isCoupleRoom(currentRoom) ? findNextAvailableNo(cfg) : null;

    for (let r=0; r<cfg.dans; r++){
      const dan = cfg.dans - r;

      const row = document.createElement("div");
      row.className = "row";

      const label = document.createElement("div");
      label.className = "dan-label";
      label.textContent = `${dan}단`;
      row.appendChild(label);

      const grid = document.createElement("div");
      grid.className = "grid";
      grid.style.gridTemplateColumns = `repeat(${cfg.cols}, var(--cell-w))`;

      for (let c=0; c<cfg.cols; c++){
        const idx = c * cfg.dans + r;
        const num = cfg.start + idx;

        if (num > cfg.end){
          const blank = document.createElement("div");
          blank.className = "niche blank";
          grid.appendChild(blank);
          continue;
        }

        const noStr = pad5(num);
        const rec = infoByRoom[cfg.room][noStr];
        const used = (rec?.status === "used");

        const niche = document.createElement("div");
        niche.dataset.no = noStr;
        niche.dataset.room = cfg.room;

        niche.className = used ? "niche used" : "niche empty";

        const top = document.createElement("div");
        top.className = "niche-top";
        top.innerHTML = iconHtml(used);
        niche.appendChild(top);

        if (nextNo && noStr === nextNo) niche.classList.add("next-slot");

        const no = document.createElement("div");
        no.className = "niche-no";
        no.textContent = noStr;
        niche.appendChild(no);

        if (used){
          niche.addEventListener("click", () => openModal(cfg.room, noStr, dan));
        }

        grid.appendChild(niche);
      }

      row.appendChild(grid);
      host.appendChild(row);
    }

    if (autoScrollNext){
      requestAnimationFrame(() => scrollNextSlotIntoCenter());
    }
  }

  function computeNextForRooms(rooms){
    let best = null;
    for (const room of rooms){
      const cfg = ROOM_CFG[room];
      if (!cfg) continue;
      const no = findNextAvailableNo(cfg);
      if (!no) continue;
      const num = parseInt(no, 10);
      if (!best || num < best.num) best = { room, no, num };
    }
    return best;
  }

  function updateNextUI(){
    nextCouple = computeNextForRooms(COUPLE_ROOMS);

    const wrap = $("nextWrap");
    const cText = $("nextCoupleText");
    const cBtn = $("nextCoupleMoveBtn");

    const hasAny = !!nextCouple;
    wrap.style.display = hasAny ? "flex" : "none";
    if (!hasAny) return;

    const cfg = ROOM_CFG[nextCouple.room];
    const dan = danOfNo(cfg, nextCouple.no);

    cText.textContent = `${nextCouple.room} ${nextCouple.no} (${dan}단)`;
    cBtn.disabled = false;
  }

  $("nextCoupleMoveBtn").addEventListener("click", () => {
    if (!nextCouple) return;
    setRoom(nextCouple.room, false);
    requestAnimationFrame(() => focusCell(nextCouple.room, nextCouple.no));
  });

  function guessHeaderRow(aoa){
    for (let r=0; r<Math.min(10, aoa.length); r++){
      const s = (aoa[r]||[]).map(x => String(x||"").trim());
      if (s.includes("봉안번호") && s.includes("반환일자")) return r;
    }
    return 0;
  }
  function buildIndexFromHeader(headerRow){
    const idx = { "안치일자":-1, "봉안번호":-1, "사망자명":-1, "신청자명":-1, "반환일자":-1 };
    headerRow.forEach((h,i) => { const key = String(h||"").trim(); if (key in idx) idx[key] = i; });
    return idx;
  }
  function extractNo5(text){
    if (!text) return null;
    const m = String(text).trim().match(/(\d{5})\s*$/);
    return m ? m[1] : null;
  }
  function extractRoomToken(text){
    const s = String(text || "").trim();
    const parts = s.split("-").map(x => x.trim()).filter(Boolean);
    for (const p of parts){
      if (/^\d{2}실$/.test(p) && ROOM_CFG[p]) return p;
    }
    return null;
  }
  function pushUnique(arr, value){
    const v = String(value ?? "").trim();
    if (!v) return;
    if (!arr.includes(v)) arr.push(v);
  }
  function isBlank(v){
    const s = String(v ?? "").trim();
    return s === "" || s === "-" || s === "0";
  }

  function parseExcelDate(v){
    if (v instanceof Date && !isNaN(v.getTime())) return v;
    if (typeof v === "number" && isFinite(v)) {
      const ms = (v - 25569) * 86400 * 1000;
      const d = new Date(ms);
      return isNaN(d.getTime()) ? null : d;
    }
    const s = String(v ?? "").trim();
    if (!s) return null;
    const m = s.match(/(\d{4})\D+(\d{1,2})\D+(\d{1,2})/);
    if (m) {
      const y = parseInt(m[1],10);
      const mo = parseInt(m[2],10);
      const da = parseInt(m[3],10);
      const d = new Date(y, mo-1, da);
      return isNaN(d.getTime()) ? null : d;
    }
    const d = new Date(s);
    return isNaN(d.getTime()) ? null : d;
  }
  function fmtDate(d){
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,"0");
    const da = String(d.getDate()).padStart(2,"0");
    return `${y}-${m}-${da}`;
  }
  function addYearsMinusOneDay(d, years){
    const x = new Date(d.getTime());
    x.setFullYear(x.getFullYear() + years);
    x.setDate(x.getDate() - 1);
    return x;
  }

  // ✅ “반환일자 없는 중복 봉안번호” = 재사용(재안치)로 처리
  // 처리 규칙:
  // - 동일 room/no5에 대해 기록 여러 개가 있으면
  //   1) 미반환(returned=false) 중에서 가장 최신(안치일자 기준, 없으면 입력순) = 현재 사용중
  //   2) 미반환이 하나도 없고 반환만 있으면 -> 반환 자리(재사용 전)로 보고
  //      - status는 used로 두되 (표시 없게)
  //      - 모달은 “반환 기록”의 사용자 정보(= 반환 전) 표시
  function applyExcel(aoa){
    for (const room of Object.keys(infoByRoom)) infoByRoom[room] = {};

    if (!aoa || aoa.length === 0) { setMsg("엑셀 비어있음", "error"); return; }
    setMsg("");

    const headerRowIndex = guessHeaderRow(aoa);
    const header = aoa[headerRowIndex] || [];
    const idx = buildIndexFromHeader(header);
    const hasHeader = idx["봉안번호"] !== -1;

    const iBurial = hasHeader ? idx["안치일자"] : 0;
    const iNo     = hasHeader ? idx["봉안번호"] : 1;
    const iDead   = hasHeader ? idx["사망자명"] : 2;
    const iApplicant = hasHeader ? idx["신청자명"] : 3;
    const iRet    = hasHeader ? idx["반환일자"] : 4;

    const startRow = hasHeader ? headerRowIndex + 1 : headerRowIndex;

    // 1) 먼저 모든 row를 room/no5별로 모으기
    const bucket = {}; // key: `${room}|${no5}` -> entries[]
    let seq = 0;

    for (let r=startRow; r<aoa.length; r++){
      const row = aoa[r] || [];
      const burialNoStr = String(row[iNo] ?? "").trim();
      if (!burialNoStr) continue;

      const room = extractRoomToken(burialNoStr);
      if (!room) continue;

      const no5 = extractNo5(burialNoStr);
      if (!no5) continue;

      const n = parseInt(no5, 10);
      const cfg = ROOM_CFG[room];
      if (!cfg || n < cfg.start || n > cfg.end) continue;

      const returned = !isBlank(row[iRet]); // 반환일자 있으면 반환 기록
      const burialRaw = row[iBurial];

      const d = parseExcelDate(burialRaw);
      const ms = d ? d.getTime() : null;

      const key = `${room}|${no5}`;
      if (!bucket[key]) bucket[key] = [];
      bucket[key].push({
        seq: seq++,
        room,
        no5,
        burialNo: burialNoStr,
        returned,
        burialDateRaw: burialRaw,
        burialDateMs: ms,
        deceasedName: row[iDead],
        applicantName: row[iApplicant]
      });
    }

    // 2) bucket을 최종 infoByRoom로 변환
    for (const [key, entries] of Object.entries(bucket)){
      if (!entries || entries.length === 0) continue;

      // 최신 판단: (안치일자 있으면 그걸 우선) 없으면 seq(입력순)
      function sortKey(e){
        // burialDateMs가 있으면 그걸 사용, 없으면 -Infinity로 두되 seq로 보정
        return {
          hasDate: e.burialDateMs != null,
          ms: e.burialDateMs != null ? e.burialDateMs : -Infinity,
          seq: e.seq
        };
      }

      const actives = entries.filter(e => !e.returned);
      const returns = entries.filter(e => e.returned);

      let chosen = null;
      let chosenIsReturned = false;

      if (actives.length > 0){
        actives.sort((a,b)=>{
          const ka = sortKey(a), kb = sortKey(b);
          if (ka.ms !== kb.ms) return ka.ms - kb.ms;
          return ka.seq - kb.seq;
        });
        chosen = actives[actives.length - 1]; // 최신 미반환
        chosenIsReturned = false;
      } else if (returns.length > 0){
        returns.sort((a,b)=>{
          const ka = sortKey(a), kb = sortKey(b);
          if (ka.ms !== kb.ms) return ka.ms - kb.ms;
          return ka.seq - kb.seq;
        });
        chosen = returns[returns.length - 1]; // 최신 반환 기록(= 반환 전 정보)
        chosenIsReturned = true;
      } else {
        continue;
      }

      const [room, no5] = key.split("|");
      const rec = {
        status: "used",            // ✅ 반환도 used로 처리 (표시는 없음)
        returned: chosenIsReturned, // 내부용(검색 제외 등)
        burialNo: chosen.burialNo || "",
        deceasedNames: [],
        applicantNames: [],
        burialDatesRaw: [],
        _effectiveDateMs: chosen.burialDateMs != null ? chosen.burialDateMs : Date.now()
      };

      // 이름/신청자/안치일자 누적(선택된 레코드만 “대표”로 보여주되, 같은 타입 중복 데이터가 있을 수 있어 안전하게 entries에서 합치기)
      // - 현재(미반환)로 선택된 경우: 미반환 엔트리들 중에서 같은 번호의 값들을 조금 더 합쳐줌
      // - 반환으로 선택된 경우: 반환 엔트리들 중에서 합쳐줌
      const pool = chosenIsReturned ? returns : actives;

      for (const e of pool){
        pushUnique(rec.deceasedNames, e.deceasedName);
        pushUnique(rec.applicantNames, e.applicantName);
        if (!isBlank(e.burialDateRaw)) rec.burialDatesRaw.push(e.burialDateRaw);
      }

      infoByRoom[room][no5] = rec;
    }

    updateNextUI();
    buildLegend();
    renderTabs();
    renderRoomButtons();
    renderRoom(true);
    saveState();
  }

  async function loadExcelFromUrl(){
    try{
      setMsg("");
      const res = await fetch(EXCEL_URL, { cache: "no-store" });
      if (!res.ok) throw new Error("fetch fail");
      const buf = await res.arrayBuffer();
      const wb = XLSX.read(buf, { type:"array" });
      const ws = wb.Sheets[wb.SheetNames[0]];
      const aoa = XLSX.utils.sheet_to_json(ws, { header:1, defval:"" });
      applyExcel(aoa);
    } catch(err){
      setMsg("엑셀 로딩 실패", "error");
    }
  }

  function openModal(room, noStr, dan){
    const rec = infoByRoom[room]?.[noStr];
    if (!rec || rec.status !== "used") return;

    $("modalTitle").textContent = `${room} ${dan}단 ${noStr}`;

    const deceased = (rec.deceasedNames && rec.deceasedNames.length)
      ? `<ul class="list">${rec.deceasedNames.map(n => `<li>${escapeHtml(n)}</li>`).join("")}</ul>`
      : "—";

    const applicant = (rec.applicantNames && rec.applicantNames.length)
      ? `<ul class="list">${rec.applicantNames.map(n => `<li>${escapeHtml(n)}</li>`).join("")}</ul>`
      : "—";

    // ✅ 반환 자리(재사용 전)도 “반환 전 사용자 정보”가 들어가므로 그대로 계산
    let startDate = null;
    for (const raw of (rec.burialDatesRaw || [])){
      const d = parseExcelDate(raw);
      if (!d) continue;
      if (!startDate || d.getTime() < startDate.getTime()) startDate = d;
    }
    const periodText = startDate
      ? `<div class="mono">${fmtDate(startDate)}<br>~ ${fmtDate(addYearsMinusOneDay(startDate, 15))}</div>`
      : `<div class="mono">—</div>`;

    $("modalBody").innerHTML = `
      <div class="kv">
        <div class="k">고인명</div><div class="v">${deceased}</div>
        <div class="k">신청자</div><div class="v">${applicant}</div>
        <div class="k">사용기간</div><div class="v">${periodText}</div>
      </div>
    `;

    $("modalBackdrop").style.display = "flex";
  }

  function closeModal(){ $("modalBackdrop").style.display = "none"; }
  $("modalCloseBtn").addEventListener("click", closeModal);
  $("modalBackdrop").addEventListener("click", (e) => { if (e.target.id === "modalBackdrop") closeModal(); });
  window.addEventListener("keydown", (e) => { if (e.key === "Escape") closeModal(); });

  function findRoomByNo(noStr){
    const n = parseInt(noStr, 10);
    if (!Number.isFinite(n)) return null;
    for (const cfg of ROOM_LIST){
      if (n >= cfg.start && n <= cfg.end) return cfg.room;
    }
    return null;
  }

  function focusCell(room, noStr){
    const el = document.querySelector(`.niche[data-room="${room}"][data-no="${noStr}"]`);
    if (!el) return;
    el.scrollIntoView({ behavior:"smooth", block:"center", inline:"center" });
    el.classList.remove("flash"); void el.offsetWidth; el.classList.add("flash");
  }

  function normalizeText(text){
    return String(text || "").trim().replace(/\s+/g, "").toLowerCase();
  }

  // ✅ 이름 검색: 반환 기록은 결과에서 제외(외부 노출 최소화)
  function searchByName(query){
    const normalized = normalizeText(query);
    if (normalized.length < 2) return [];

    const results = [];
    for (const room of Object.keys(infoByRoom)){
      for (const [noStr, rec] of Object.entries(infoByRoom[room])){
        if (rec.status !== "used") continue;
        if (rec.returned) continue; // ✅ 반환(재사용 전) 기록은 검색 제외

        for (const name of (rec.deceasedNames || [])){
          const normName = normalizeText(name);
          if (normName.includes(normalized)){
            const cfg = ROOM_CFG[room];
            const dan = danOfNo(cfg, noStr);
            results.push({
              room,
              noStr,
              dan,
              name,
              burialNo: rec.burialNo || ""
            });
            break;
          }
        }
      }
    }
    return results;
  }

  function showSearchResults(results){
    const container = $("searchResults");
    if (!results || results.length === 0){
      container.classList.remove("show");
      return;
    }

    container.innerHTML = results.map((r, idx) => `
      <div class="search-result-item" data-idx="${idx}">
        <div class="search-result-name">${escapeHtml(r.name)}</div>
        <div class="search-result-detail">${r.room} ${r.dan}단 ${r.noStr}</div>
      </div>
    `).join("");

    container.classList.add("show");

    container.querySelectorAll(".search-result-item").forEach((el, idx) => {
      el.addEventListener("click", () => {
        const result = results[idx];
        container.classList.remove("show");
        $("searchInput").value = "";

        setRoom(result.room, false);
        requestAnimationFrame(() => {
          focusCell(result.room, result.noStr);
          setTimeout(() => openModal(result.room, result.noStr, result.dan), 600);
        });
      });
    });
  }

  function onSearch(){
    setMsg("");
    const raw = ($("searchInput").value || "").trim();
    if (!raw) return;

    const compact = raw.replace(/\s+/g, "");
    const digits = compact.replace(/\D/g, "");

    if (digits.length >= 2 && digits.length <= 5 && digits.length === compact.length){
      const noStr = digits.padStart(5,"0");
      const room = findRoomByNo(noStr);
      if (!room){
        setMsg("해당 번호를 찾을 수 없습니다.", "error");
        return;
      }

      $("searchResults").classList.remove("show");
      setRoom(room, false);
      requestAnimationFrame(() => focusCell(room, noStr));
      return;
    }

    if (raw.length >= 2){
      const results = searchByName(raw);
      if (results.length === 0){
        setMsg("검색 결과가 없습니다.", "error");
        $("searchResults").classList.remove("show");
      } else {
        setMsg("");
        showSearchResults(results);
      }
    } else {
      setMsg("고인명은 2자 이상 입력해 주세요.", "error");
    }
  }

  $("searchBtn").addEventListener("click", onSearch);
  $("searchInput").addEventListener("keydown", (e) => {
    if (e.key === "Enter") onSearch();
  });

  $("searchInput").addEventListener("input", () => {
    const val = ($("searchInput").value || "").trim();
    if (val.length === 0){
      $("searchResults").classList.remove("show");
      setMsg("");
    }
  });

  document.addEventListener("click", (e) => {
    if (!e.target.closest(".search")){
      $("searchResults").classList.remove("show");
    }
  });

  $("reloadBtn").addEventListener("click", loadExcelFromUrl);

  restoreState();
  buildLegend();
  renderTabs();
  renderRoomButtons();
  renderRoom(false);
  loadExcelFromUrl();
</script>
</body>
</html>
